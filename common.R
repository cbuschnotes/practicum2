###Chris Busch's
###common functions
###useful R code accumulated over the years
#require(formula.tools); ##for better display of formulas from print
#require(lmtest);

#https://www.rdocumentation.org/packages/formula.tools/versions/1.5.4/topics/as.character.formula
as.character.formula=function(x) Reduce( paste, deparse(x) )

common.memory<<-c('');
memorize.push=function(x) {common.memory<<-c(common.memory,x);}
memorizeSome=function(...) {
  say(...);
  for(i in (list(...))) { 
    memorize.push(as.character(i));
    memorize.push(' ')
  }
}
memorize=function(...) {
  memorizeSome(...);
  memorize.push('\n');
}
show.memory=function() {
  for(i in common.memory){
    cat(i);
  }
  common.memory<<-c('');
}

ram.memory<<-list();
ram=function(key,...){
  say(key,':',...);
  values=list(...)
  values=as.character(values);
  values=c(values,"\n");
  if(is.null(ram.memory[[key]])){
    ram.memory[[key]]<<-values;
  }else{
    ram.memory[[key]]<<-c(ram.memory[[key]],values);
  }
}
show.ram=function(reset=T){
  for(n in names(ram.memory)){
    cat("\n---",n,"---\n");
    for(i in ram.memory[[n]]){
      cat(i);
      cat(" ");
    }
  }
  if(reset) ram.memory<<-list();
}

more <- function(cmd,nlines=10){
  output = capture.output(cmd)
  pages = seq(1,length(output),by=nlines)
  for(p in pages){
    f = p
    l = min(p+nlines-1,length(output))
    cat(paste(output[f:l],"\n"))
    readline("*more*")
  }
  return(invisible(0))
}
grepprint <- function(string,cmd){
  output=capture.output(cmd)
  cat(noquote(output[grep(string,output,fixed=T)]),sep="\n");   
  return(invisible(0))
}

given=function(.,...){ with(.,...); }
##niftier than print
say=function(...,sep=' ') {
  for(i in (list(...))) { 
    cat(as.character(i));cat(sep)
  }
  cat('\n');
}
say0=function(...){
  s=""
  for(i in (list(...))){
    if(class(i)=="Date"){
      s=paste(s,as.character(i));
    }else if(is.numeric(i) ){
      s=paste(s,prettyNum(i,big.mark=",",scientific=F))
    }else{
      s=paste(s,as.character(i));
    }
  }
  print(s);
}
say2=function(...){
  s=""
  for(i in (c(...))){
    if(class(i)=="Date"){
      s=paste(s,as.character(i));
    }else if(is.numeric(i) ){
      s=paste(s,prettyNum(i,big.mark=",",scientific=F))
    }else{
      s=paste(s,as.character(i));
    }
  }
  print(s);
}
#say(as.Date('1970-01-01'))
#http://www.r-bloggers.com/winsorization/
winsor1=function(x, fraction=.005,lbl='x',trace=T) {
  if(length(fraction) != 1 || fraction < 0 ||
     fraction > 0.5) {
    stop("bad value for 'fraction'")
  }
  lim <- quantile(x, probs=c(fraction, 1-fraction),na.rm = T)
  #memorize(lbl,"=max(",lim[1],",min(",lim[2],",",lbl,")) //limits are ",min(x,na.rm=T),lim,max(x,na.rm=T))
  if(trace) say(lbl,"=max(",lim[1],",min(",lim[2],",",lbl,")); //limits are ",min(x,na.rm=T),lim,max(x,na.rm=T))
  x[ x < lim[1] ] <- lim[1]
  x[ x > lim[2] ] <- lim[2]
  x
}

winsor1Df=function(df,cols=names(df),ignore=c(),trace=T,...){
  if(trace) cat("void winsor(){ //generated by winsor1Df \n")
  for(f in cols){
    if(f %in% ignore) next;
    if(f %in% names(df)){
      #if(is.numeric(df[,f])) df[,f]=winsor1(df[,f],lbl=f,trace=trace, ...);
      if(is.numeric(df[[f]])) df[[f]]=winsor1(df[[f]],lbl=f,trace=trace, ...);
    }
  }  
  if(trace) cat("}\n\n")
  df;
}


trim1=function(x, fraction=.005,lbl='x') {
  if(length(fraction) != 1 || fraction < 0 ||
     fraction > 0.5) {
    stop("bad value for 'fraction'")
  }
  lim <- quantile(x, probs=c(fraction, 1-fraction),na.rm = T)
  say(lbl,"=max(",lim[1],",min(",lim[2],",",lbl,")) //trimming limits are ",min(x,na.rm=T),lim,max(x,na.rm=T))
  x[ x < lim[1] ] <- NA;
  x[ x > lim[2] ] <- NA;
  x
}


trimDf=function(df,cols=names(df),ignore=c(),...){
  for(f in cols){
    if(f %in% ignore) next;
    if(is.numeric(df[,f])) { df[,f]=trim1(df[,f],lbl=f,...);}
    else{ message("ignoring ",f);}
  }  
  say("did not trim",round(100*length(which(complete.cases(df)))/nrow(df)),"%")
  df[complete.cases(df),];
}

strindex=function(s,p,every=F,last=F,fixed=T){ ##NOT VECTORIZED
  if(every){
    (grep(p, strsplit(s, '')[[1]],fixed = fixed))
  }else if(last){
    rev((grep(p, strsplit(s, '')[[1]],fixed = fixed)))[1]
  }else{
    ((grep(p, strsplit(s, '')[[1]],fixed = fixed)))[1]
  }
}

printJavaVariables=function(df){
  cat("//declaration generated by printJavaVariables\n")
  for(n in names(df)){
    if(class(df[,n])=='character'){
      say("String ",n,'= null;'); 
      df[,n]=NULL
    }else{
      say("double ",gsub('\\.','_',n),"= Double.NaN; //range:",range(df[,n],na.rm = T) );
    }
  }
  cat("\nvoid create(){ //create generated by printJavaVariables\n")
  for(n in names(df)){
    i=strindex(n,'_',last = T)
    if(!is.na(i) && i>0){
      cat(n,' = ',substr(n,i+1,nchar(n)),'(',substr(n,1,i-1),');\n',sep='')
    }
  }
  cat("}\n\n")
}

is.all.whole.numbers=function(x) all(floor(x)==x);

impute=function(df,cols=names(df),ignore=c(),trace=T,missing.threshold=0.7,...){
  if(trace) cat("void impute(){\n")
  for(c in cols){
    if(c %in% ignore) next;
    x=df[,c]
    missed=is.na(x)
    if(is.numeric(x)){
      m=0;
      nax=na.omit(x);
      if(length(unique(nax))==2){ ##indicator so use mode
        m=Mode(unique(nax))
      }else{     
        m=mean(x,trim = 0.005,na.rm = T)
      }
      if(is.all.whole.numbers(nax)){
        m=round(m); #round to whole number
      }
      if(length(which(missed))/nrow(df)>missing.threshold){
        df[,c]=NULL
        if(trace) say("// ",c,"removed due to ",round(100*length(which(missed))/nrow(df)),"% missing")
      }else{
        if(trace) cat(c,' = isnull(',c,',',m,'); //',round(100*length(which(missed))/nrow(df)),
                      ifelse(any(missed),"% imputed","none imputed"),"\n",sep="");
        df[is.na(x),c]=m;
      }
    }else{ ##string data
      if(all(is.na(x)) || length(unique(x[!is.na(x)]))<2 || length(unique(x[!is.na(x)]))>100){
        df[,c]=NULL
        if(trace) say("// ",c,"removed junk ",length(unique(x)),all(is.na(x)),
                      length(unique(x[!is.na(x)])),
                      length(unique(x[!is.na(x)])))
      }else if(length(which(missed))/nrow(df)>missing.threshold){
        df[,c]=NULL
        if(trace) say("// ",c,"removed due to ",round(100*length(which(missed))/nrow(df)),"% missing")
      }else{
        
        nax=na.omit(x);
        m=Mode(nax)
        if(trace) cat(c,' = isnull(',c,',"',m,'"); //',round(100*length(which(missed))/nrow(df)),
                      ifelse(any(missed),"% imputed","none imputed"),"\n",sep="");
        df[is.na(x),c]=m;
      }
    }
  }  
  if(trace) cat("}\n\n")
  df;
}

winsor2=function(x, multiple=3){
  if(length(multiple) != 1 || multiple <= 0) {
    stop("bad value for 'multiple'")
  }
  med <- median(x)
  y <- x - med
  sc <- mad(y, center=0) * multiple
  say("pivot2 is ",min(x),(med-sc),(med+sc),max(x))
  y[ y > sc ] <- sc
  y[ y < -sc ] <- -sc
  y + med
}

##converts an Excel date to a R date
toDate=function(x) {
  as.Date(x,origin = "1899-12-30");
}

##rmse aka
stdevp=function(x){ sqrt(sum((x-mean(x))^2)/(length(x)));}

trimLeftGap=function(xvar,df,gap=10){
  ##this trims the left of a big gap in data. 
  #This may be due to a customer leaving and coming back.
  diffs=diff(df[,xvar]); 
  biggap=mean(diffs)*gap; ##that gap space is odd
  start=max(which(diffs>biggap))+1;
  if(!is.infinite(start)){
    print(paste("Trimming up to ",start,' of ',nrow(df),' for ',(start/nrow(df))));
    gooddf=df[start:nrow(df),]; 
    return(gooddf);
  }else{
    return(df);
  }
}
trimLeftGapZ=function(xvar,df,zscore=1){
  ##this trims the left of a big gap in data. This may be due to a customer leaving and coming back.
  diffs=diff(df[,xvar]); 
  biggap=mean(diffs)+zscore*stdevp(diffs); ##that gap space is odd
  start=max(which(diffs>biggap))+1;
  if(!is.infinite(start)){
    print(paste("Trimming up to ",start,' of ',nrow(df),' for ',(start/nrow(df))));
    gooddf=df[start:nrow(df),]; 
    return(gooddf);
  }else{
    return(df);
  }
}


rsqWrong=function(actual,pred){ 
  return (sum((pred-mean(actual))^2)/sum((actual-mean(actual))^2)); 
}
rmse=function(x,y,k=0,weights=rep(1,length(x))){
  return( sqrt(sum((x-y)^2*weights)/(sum(weights)-k)));
}

mad.error=function(x,y,k=0){
  return( (sum(abs(x-y))/(length(x)-k)));
}

rsq=function(actual,pred){ 
  return( cor(actual,pred,method=c("pearson"),use="complete.obs")^2);
}

adj.rsq=function(actual,pred,p=1){ 
  r2=rsq(actual,pred);
  n=length(actual);
  return( 1 - (1-r2)*(n-1)/(n-p-1));
}

findBestTrend=function(data,yvar,xvar,attempt=types){
  #This figures out the best Excel-like trend function based on lowest rmse
  #returns list of model,fit,lwr,upr,modelNum,rmse,rsq,type
  ##TODO REFACTOR IN MORE OO STYLE
  ##PLEASE REWRITE THIS!
  types=c('power','exponential','logarithmic','linear'); 
  formulaStrings=list(paste("log(",yvar,")~log(",xvar,")"),
                      paste("log(",yvar,")~",xvar,""),
                      paste("",yvar,"~log(",xvar,")"),
                      paste("",yvar,"~",xvar,"")); 
  same=function(x){x};
  YFUN=list(exp,exp,same,same);
  models=list();
  fun=list();
  predicted=list();
  lwrs=list();
  fits=list();
  uprs=list();
  rmses=c();
  rsqs=c();
  for(i in 1:4){
    if(types[i] %in% attempt){ 
      models[[i]]=lm(as.formula(formulaStrings[[i]]),data);
      fun[[i]]=function(data){
        predicted=as.data.frame(predict(models[[i]],data,interval="prediction"));
        predicted$lwr=YFUN[[i]]( predicted$lwr );
        predicted$fit=YFUN[[i]]( predicted$fit );
        predicted$upr=YFUN[[i]]( predicted$upr );
        predicted;
      }
      predicted[[i]]=fun[[i]](data);
      lwrs[[i]]=predicted[[i]]$lwr;
      fits[[i]]=predicted[[i]]$fit;
      uprs[[i]]=predicted[[i]]$upr;
      ## 
      rmses[i]=rmse(data[,yvar],fits[[i]]);
      rsqs[i]=rsq(data[,yvar],fits[[i]]);
      say(types[i],formulaStrings[[i]], 
          "rmse is",rmses[i],
          "rsq is",rsqs[i],
          "summary$r.squared",summary(models[[i]])$r.squared);
    }
  }
  #best=min(rmses,na.rm = T)
  best=max(rsqs,na.rm = T)
  for(i in (1:4)){
    #if(best==rmses[i]){
    if(!is.na(rsqs[i]) && best==rsqs[i]){
      return(list(model=models[[i]],
                  fit=fits[[i]],
                  lwr=lwrs[[i]],
                  upr=uprs[[i]],
                  modelNum=i,
                  rmse=best,
                  rsq=rsqs[i],
                  type=types[i],
                  predictFun=fun[[i]],
                  formulaString=formulaStrings[[1]]
      )); 
    }
  }
}
addBestPredictions=function(best,newdata,prefix=''){
  ##Adds in the predictions 
  results=best$predictFun(newdata);
  newdata[[paste0(prefix,'.lwr')]]=results[['lwr']]
  newdata[[paste0(prefix,'.upr')]]=results[['upr']]
  newdata[[paste0(prefix,'.fit')]]=results[['fit']]
  return(newdata);
}

addPredictions=function(cpumodel,newdata,prefix=''){
  ##Adds in the predictions 
  say("say ",summary(cpumodel)$call,"adj.r.squared is",summary(cpumodel)$adj.r.squared);
  predicted=as.data.frame(predict(cpumodel,newdata,interval="prediction"))
  newdata[[paste0(prefix,'.lwr')]]=predicted$lwr
  newdata[[paste0(prefix,'.upr')]]=predicted$upr
  newdata[[paste0(prefix,'.fit')]]=predicted$fit 
  return(newdata);
}

ezplot3=function(df,yvars=names(df),xvar=NULL,xlab=xvar,ylab='values',
                 title='',type='p',
                 col=c("red", "orange", "blue", "cyan", 
                       "green", "lightgreen", "violet", 
                       "pink", "black", "brown", "yellow")){
  #style can be geom_line or geom_point 
  colused=c();
  yvars;
  if(is.null(xvar)){
    df$ROW=c(1:nrow(df))
    xvar='ROW';
  }
  g=ggplot();
  c=0;
  for( yvar in (yvars)){
    if(yvar==xvar){
      ##ignore
    }else if(class(df[1,yvar])=='Date') {
      warning(paste("Skipping Date yvar",yvar)); 
    }else{ 
      c=c+1
      uc=col[c%%length(col)]
      if(type=='p'){
        g=g+geom_point(data=df,
                       aes_string(x=xvar,y=yvar),colour=uc,shape=(c %% 25));
      }else{ 
        g=g+geom_line(data=df,
                      aes_string(x=xvar,y=yvar),colour=uc,shape=(c %% 25)); 
      }
      colused=c(colused, uc);
      title=paste0(title," ",yvar,":",uc); #lame fix for lack of legend
    }
  }
  g=g+scale_shape_identity()
  g=g+labs(title=title,x=xlab,y=ylab)
  g=g+theme_classic();
  print(g);
}
ezplot1=function(df,yvars=names(df),xvar=NULL,xlab=NULL,ylab='values',
                 title=sys.call(),type='p',
                 col=darken(rainbow(length(yvars)+1))
                 # col=c("red", "orange", "blue", "cyan", 
                 #       "green", "violet", 
                 #       "pink", "black", "brown", "yellow","magenta","gray","lightgreen")
){ 
  yvars=yvars;
  if(is.null(xvar)){
    df$ROW=c(1:nrow(df))
    xvar='ROW';
  }
  df=df[order(df[,xvar]),];
  colused=c();
  labels=c();
  ltys=c();
  pchs=c();  
  minX=min(df[,xvar],na.rm=T);
  maxX=max(df[,xvar],na.rm=T);
  minY=Inf;
  maxY=-Inf;
  marks=list(topleft=0,bottomleft=0,topright=0,bottomright=0);
  for( yvar in (yvars)){
    if(yvar==xvar){
      ##ignore
    }else if(class(df[1,yvar])=='Date') {
      warning(paste("Skipping Date yvar",yvar)); 
    }else{ 
      minY=min(minY,min(df[[yvar]],na.rm=T));
      maxY=max(maxY,max(df[[yvar]],na.rm=T));
      #       say(marks$bottomleft,sum(df[,xvar]<(maxX+minX)/2 & df[,yvar]<(maxY+minY)/2))
      #       say(marks$topright,sum(df[,xvar]>(maxX+minX)/2 & df[,yvar]>(maxY+minY)/2))
      #       say(marks$topleft,sum(df[,xvar]<(maxX+minX)/2 & df[,yvar]>(maxY+minY)/2))
      #       say(marks$bottomright,sum(df[,xvar]>(maxX+minX)/2 & df[,yvar]<(maxY+minY)/2))
      
      incIgnoreNA(marks$bottomleft,sum(df[,xvar]<(maxX+minX)/2 & df[,yvar]<(maxY+minY)/2))
      incIgnoreNA(marks$topright,sum(df[,xvar]>(maxX+minX)/2 & df[,yvar]>(maxY+minY)/2))
      incIgnoreNA(marks$topleft,sum(df[,xvar]<(maxX+minX)/2 & df[,yvar]>(maxY+minY)/2))
      incIgnoreNA(marks$bottomright,sum(df[,xvar]>(maxX+minX)/2 & df[,yvar]<(maxY+minY)/2))      
    }
  }  
  #   print(marks)
  if(is.null(xlab)){
    if(class(df[1,xvar])=='Date'){
      xlab=paste(xvar,"(",minX,",",maxX,")")
    }else{
      xlab=paste(xvar,"(",signif(round(minX,2),2), ",",signif(round(maxX,2),2),")")
    }
  }
  # Add extra space to right of plot area; change clipping to figure
  #par(mar=c(5.1, 4.1, 4.1, 8.1)) #, xpd=TRUE
  loop=0; 
  for( yvar in (yvars)){
    if(yvar==xvar){
      ##ignore
    }else if(class(df[1,yvar])=='Date') {
      warning(paste("Skipping Date yvar",yvar)); 
    }else{ 
      loop=loop+1
      uc=col[(loop%%length(col))+1]
      colused=c(colused, uc);
      ltys=c(ltys,ifelse(type=='p',0,1)); 
      if(type!='l')   pchs=c(pchs,loop %% 25);
      labels=c(labels,yvar);
    }
  }
  loop=0; 
  for( yvar in (yvars)){
    if(yvar==xvar){
      ##ignore
    }else if(class(df[1,yvar])=='Date') {
      warning(paste("Skipping Date yvar",yvar)); 
    }else{ 
      loop=loop+1
      uc=col[(loop%%length(col))+1]
      if(loop==1) {
        #simpler to include bty = "n" in legend than do this first ...
        plot(NA,type=type,xlab=xlab, ylab=ylab,ylim=c(minY,maxY),xlim=c(minX,maxX))
        grid()
        spot=names(sort(unlist(marks),decreasing = F))[1];
        legend(spot, 
               labels,lty=ltys,pch=pchs,lwd=c(2.5,2.5),col=colused,
               horiz=F,
               x.intersp=0,xjust=0,yjust=0         )  
        lines(df[[xvar]],df[[yvar]],col=uc,type=type,pch=loop %% 25)       
      }else{
        lines(df[[xvar]],df[[yvar]],col=uc,type=type,pch=loop %% 25) 
      }
      catln(type)
    }
  }
  if(type=='l') {pchs=NULL}       
  title(main=title); 
  Sys.sleep(0) #frame();
}
ezplot2a=function(df,yvars=names(df),xvar=NULL,xlab=xvar,ylab='values',
                  title=sys.call(),type='p',
                  col=rainbow(length(yvars)+1)
                  # col=c("red", "orange", "blue", 
                  #                                 "green", "violet", 
                  #                                 "pink", "black", "brown",
                  #                                 "yellow","cyan","lightgreen")
){
  require(ggplot2)
  require(reshape2)
  require(ggthemes);
  
  yvars=yvars;
  if(is.null(xvar)){
    df$ROW=c(1:nrow(df))
    xvar='ROW';
  }
  yvars2=c();
  for( yvar in (yvars)){
    if(yvar==xvar){
      ##ignore
    }else if(class(df[1,yvar])=='Date') {
      warning(paste("Skipping Date yvar",yvar)); 
    }else{ 
      yvars2=c(yvars2, yvar);
    }
  }
  yvars=yvars2; 
  colused=c();
  labels=c();
  ltys=c();
  pchs=c();
  loop=0;
  minY=Inf;
  maxY=-minY 
  for( yvar in (yvars)){
    minY=min(minY,min(df[[yvar]],na.rm=T));
    maxY=max(maxY,max(df[[yvar]],na.rm=T));
    loop=loop+1
    colused=c(colused, col[loop%%length(col)]);
    pchs=c(pchs,loop %% 25);
  }
  df <- melt(df , id = xvar, measure.vars=yvars,variable.name = 'series')
  g=ggplot(df, aes_string(xvar,'value')) 
  g=g+#theme_bw(base_size = 18)+
    scale_shape_manual(values=pchs)+
    scale_color_manual(values=colused);
  number_ticks <- function(n) {function(limits) pretty(limits, n)}
  g=g+scale_y_continuous(breaks=number_ticks(n=7))
  if(type=='p'){
    g=g+geom_point(aes_string(colour = 'series',shape='series'),size=2)
  }else if(type=='l'){
    g=g+geom_line(aes_string(colour = 'series',linetype='series'),size=1.2)
  }else{
    g=g+geom_line(aes_string(colour = 'series'),size=1)+
      geom_point(aes_string(colour = 'series',shape='series'),size=2)
  }
  g=g+labs(title=title,x=xlab,y=ylab)
  print(g);
}

ezplot2=function(df,yvars=names(df),xvar=NULL,xlab=xvar,ylab='values',
                 title=sys.call(),type='p',
                 col=rainbow(length(yvars)+1),
                 h=NULL,v=NULL
){
  require(ggplot2)
  require(reshape2)
  require(ggthemes);
  
  yvars=yvars;
  if(is.null(xvar)){
    df$ROW=c(1:nrow(df))
    xvar='ROW';
  }
  yvars2=c();
  for( yvar in (yvars)){
    if(yvar==xvar){
      ##ignore
    }else if(class(df[1,yvar])=='Date') {
      warning(paste("Skipping Date yvar",yvar)); 
    }else{ 
      yvars2=c(yvars2, yvar);
    }
  }
  yvars=yvars2; 
  colused=c();
  labels=c();
  ltys=c();
  pchs=c();
  loop=0;
  minY=Inf;
  maxY=-minY 
  for( yvar in (yvars)){
    minY=min(minY,min(df[[yvar]],na.rm=T));
    maxY=max(maxY,max(df[[yvar]],na.rm=T));
    loop=loop+1
    colused=c(colused, col[loop%%length(col)]);
    pchs=c(pchs,loop %% 25);
  }
  df <- melt(df , id = xvar, measure.vars=yvars,variable.name = 'series')
  g=ggplot(df, aes_string(xvar,'value')) 
  g=g+#theme_bw(base_size = 18)+
    scale_shape_manual(values=pchs)+
    scale_color_manual(values=colused);
  number_ticks <- function(n) {function(limits) pretty(limits, n)}
  if(type!='bar') g=g+scale_y_continuous(breaks=number_ticks(n=7))
  if(type=='p'){
    g=g+geom_point(aes_string(colour = 'series',shape='series'),size=2)
  }else if(type=='l'){
    g=g+geom_line(aes_string(colour = 'series'),size=1)
  }else if(type=='bar'){
    g=g+geom_bar(stat = "identity",aes_string(fill = 'series'), position = "dodge")
  }else if(type=='dl'){
    g=g+geom_line(aes_string(colour = 'series',linetype='series'),size=1.2)
  }else{
    g=g+geom_line(aes_string(colour = 'series'),size=1)+
      geom_point(aes_string(colour = 'series',shape='series'),size=2)
  }
  g=g+labs(title=title,x=xlab,y=ylab)
  if( !is.null(v)) g=g+geom_vline(xintercept = v)
  if( !is.null(h)) g=g+geom_vline(yintercept = h)
  print(g);
}



ezplot=ezplot1; 
#ezplot=function(...){}
#ezplotONLY=ezplot1;
copyColumn=function(col,srcdf,destdf){
  #copies column from src to dest, returns modified dest
  newdata=srcdf[[col]] 
  if(length(newdata)<nrow(destdf)){
    destdf[,col]=(c(newdata,rep(NA,nrow(destdf)-length(newdata))))
  }else{
    destdf[,col]=( newdata[1:nrow(destdf)] )
  }
  return(destdf);
}

##

ezplot4=function(dfList,yvars=names(df),xvar='ROW',xlab=NULL,ylab='values',
                 title=sys.call(),type='p',
                 ylim=NULL,
                 # col=c("red", "orange", "blue", "cyan", 
                 #       "green", "lightgreen", "violet", 
                 #       "pink", "black", "brown", "gray","magenta","yellow"),
                 col=rainbow(length(yvars)+1),
                 legendloc=NULL,...){ 
  if(class(dfList)=='data.frame'){
    dfList=list(.=dfList)
  }
  if(is.null(names(dfList))) stop("dfList must have names");
  colused=c();
  labels=c();
  ltys=c();
  pchs=c();
  loop=0; 
  minY=Inf;
  maxY=-Inf;
  minX=Inf;
  maxX=-Inf;
  marks=list(topleft=0,bottomleft=0,topright=0,bottomright=0);
  for( w in (names(dfList))){
    df=dfList[[w]]
    if(class(df)=='numeric'){
      warning("passed in vector, but need data.frames");
      df=data.frame(T3MP=df)
      df[[w]]=df$T3MP
      df$T3MP=NULL
    }
    yvars=yvars;
    if(length(df[[xvar]])==0){
      df[[xvar]]=c(1:nrow(df))
    } 
    minX=min(minX,min(df[[xvar]],na.rm=T));
    maxX=max(maxX,max(df[[xvar]],na.rm=T)); 
    class(minX)=class(df[[xvar]]);
    class(maxX)=class(df[[xvar]]);
    for( yvar in (yvars)){
      if(yvar==xvar){
        ##ignore
      }else if(!(yvar %in% names(df))){
        #ignore
      }else if(class(df[1,yvar])=='Date') {
        warning(paste("Skipping Date yvar",yvar)); 
      }else{ 
        minY=min(minY,min(df[[yvar]],na.rm=T));
        maxY=max(maxY,max(df[[yvar]],na.rm=T));
        ####
        incIgnoreNA(marks$bottomleft,sum(df[,xvar]<(maxX+minX)/2 & df[,yvar]<(maxY+minY)/2))
        incIgnoreNA(marks$topright,sum(df[,xvar]>(maxX+minX)/2 & df[,yvar]>(maxY+minY)/2))
        incIgnoreNA(marks$topleft,sum(df[,xvar]<(maxX+minX)/2 & df[,yvar]>(maxY+minY)/2))
        incIgnoreNA(marks$bottomright,sum(df[,xvar]>(maxX+minX)/2 & df[,yvar]<(maxY+minY)/2))  
        loop=loop+1 
        uc=col[(loop%%length(col))+1]
        colused=c(colused, uc);
        ltys=c(ltys,ifelse(type=='p',0,1)); 
        pchs=c(pchs,loop %% 25);
        labels=c(labels,ifelse(length(yvars)>1,ifelse(w=='.',yvar,paste(w,yvar)),w));
      }
    } 
  }
  if(is.null(xlab)){
    if(is.null(xlab)){
      if(class(df[1,xvar])=='Date'){
        xlab=paste(xvar,"(",minX,",",maxX,")")
      }else{
        xlab=paste(xvar,"(",signif(round(minX,2),2), ",",signif(round(maxX,2),2),")")
      }
    } 
  }
  loop=0; 
  for( w in (names(dfList))){
    df=dfList[[w]] 
    if(length(df[[xvar]])==0){
      df[[xvar]]=c(1:nrow(df))
    } 
    # Add extra space to right of plot area; change clipping to figure
    #par(mar=c(5.1, 4.1, 4.1, 8.1)) #, xpd=TRUE
    for( yvar in (yvars)){
      if(yvar==xvar){
        ##ignore
      }else if(!(yvar %in% names(df))){
        ##ignore
      }else if(class(df[1,yvar])=='Date') {
        warning(paste("Skipping Date yvar",yvar)); 
      }else{ 
        loop=loop+1 
        uc=col[(loop%%length(col))+1]        
        if(loop==1) {          
          plot(NULL,type=type,xlab=xlab, ylab=ylab,ylim=if(!is.null(ylim)){ylim}else{c(minY,maxY)},
               xlim=c(minX,maxX))          
          grid()
          #####
          if(type=='l') {pchs=NULL} 
          if(!is.null(legendloc)){
            spot=legendloc
          }else{
            spot=names(sort(unlist(marks),decreasing = F))[1];
          }
          legend(spot,y=NULL,labels,lty=ltys,pch=pchs,lwd=c(2.5,2.5),col=colused,
                 x.intersp=0,xjust=0,yjust=0,...   )
          #####          
          #           message('line',w,' xvar ',xvar)
          cat(length(df[[xvar]]),length(df[[yvar]]),"col=",uc,"type=",type,"pch=",loop %% 25) 
          #           print(summary(df[[xvar]]))
          #           print(summary(df[[yvar]]))
          lines(df[[xvar]],df[[yvar]],col=uc,type=type,pch=loop %% 25)   
        }else{
          #           message('line',w,' xvar ',xvar)
          #           message(length(df[[xvar]]),length(df[[yvar]]),"col=",uc,"type=",type,"pch=",loop %% 25) 
          #           print(summary(df[[xvar]]))
          #           print(summary(df[[yvar]]))
          #           message(length(df[[xvar]]),length(df[[yvar]]),"col=",uc,"type=",type,"pch=",loop %% 25) 
          lines(df[[xvar]],df[[yvar]],col=uc,type=type,pch=loop %% 25) 
        }
      }
    }
  }
  title(main=title); 
  Sys.sleep(0) #frame();
}
##
# returns string w/o leading whitespace
trim.leading <- function (x)  sub("^\\s+", "", x)

# returns string w/o trailing whitespace
trim.trailing <- function (x) sub("\\s+$", "", x)

# returns string w/o leading or trailing whitespace
trim <- function (x) gsub("^\\s+|\\s+$", "", x)

qw = function(...){ x=c(...); x=gdata::trim(gsub("\n"," ",x,fixed = T)); unlist(strsplit(x, "[[:space:]]+"))}
chopVec=function(x){ x[1:length(x)-1];}

inc <- function(x,y=1) { 
  if(is.null(x)){
    eval.parent(substitute(x <-  y)) 
  }else{    
    eval.parent(substitute(x <- x + y)) 
  }
}

incg <- function(x,y=1) { 
  if(is.null(x)){
    eval.parent(substitute(x <<-  y)) 
  }else{    
    eval.parent(substitute(x <<- x + y)) 
  }
}


mult <- function(x,y=1,def=0) { 
  if(is.null(x)){
    eval.parent(substitute(x <-  def)) 
  }else{    
    eval.parent(substitute(x <- x * y)) 
  }
}



incIgnoreNA <- function(x,y=1) {   
  if(is.na(y)){
    y=0; 
  }
  eval.parent(substitute(x <- ifelse(is.null(x),0,x) + y)) 
}

#actauls,predictions,tiles
actualsVsPredictions=function(a,p,tiles=min(floor(length(a)/10),20)) {
  d=data.frame(a=a,p=p);
  P=sum(a==1);
  N=sum(a==0);
  
  tiles=min(tiles,length(unique(p)))
  
  pbounds=unique(quantile(p, c(seq(0,1,1/tiles)),na.rm = T)); 
  #message("tiles=",tiles,' tiles2=',length(pbounds))
  if(length(pbounds)<2){
    return( NULL);
  }
  nr=1:(length(pbounds)-1);
  
  
  df=data.frame(tile=nr);  
  tpop=0;
  tp=tn=0;
  for(i in nr){
    df$lo[[i]]=lo=pbounds[i];
    df$hi[[i]]=hi=pbounds[i+1];
    if(i==length(nr)){
      hiLogical=d$p<=hi
      loLogical=d$p>=lo
    }else{
      hiLogical=d$p<hi
      loLogical=d$p>=lo
    }
    w=which(loLogical & hiLogical)
    fn=length(which(hiLogical & d$a==1 ));    
    tn=length(which(hiLogical & d$a==0 ));    
    fp=length(which(loLogical & d$a==0 ));    
    tp=length(which(loLogical & d$a==1 ));    
    inc(tpop,length(which(loLogical & hiLogical)));
    df$popn[[i]]=tn/N;
    df$popp[[i]]=tp/P;
    df$avgp[[i]]=mean(d[w,'p']);
    df$avga[[i]]=mean(d[w,'a']);
    #df$lengthW[[i]]=length(w)
    df$npv[[i]]=tn/(tn+fn);
    df$ppv[[i]]=tp/(tp+fp);
    df$tpr[[i]]=tp/(tp+fn)
    df$tnr[[i]]=tn/(tn+fp)        
    df$pop[[i]]=tpop/nrow(d);
  }
  
  df$tile=NULL;
  df$lo=NULL;
  df$hi=NULL;
  
  
  df;  
}

# d=data.frame(a=floor(runif(100)*2),p=runif(100))
# ezplot2(actualsVsPredictions(d$a,d$p),xvar='avgp',type='l')
# d=data.frame(a=floor(runif(100)*2),p=runif(100));ezplot3(actualsVsPredictions(d$a,d$p),xvar='avgp')


given=function(.,...) with(.,...);

#discards from df those cols
discard=function(df,cols){ 
  df=df[,!(names(df) %in% cols)]; 
  df;
}
discardSingleValues=function(df){
  for(n in names(df)){ ##DISCARD ALL one values
    if(all(is.na(df[,n]))){
      say(n," all NA");  
      df[,n]=NULL
    }else if(is.numeric(df[[n]])){
      if(max(df[[n]],na.rm=T)==min(df[[n]],na.rm=T)){
        say(n,"is a single value",max(df[[n]]));  
        df[,n]=NULL
      }      
    }
  }
  df;
}

discardEmpty=function(df,amt=0.99){
  for(n in names(df)){ ##DISCARD ALL one values
    if(sum(is.na(df[,n]))/length(df[,n])>amt){
      say(n," too empty");  
      df[,n]=NULL
    }
  }
  df;
}

#keeps in df those cols
keep=function(df,cols){   
  if(length(cols)==1){
    df=as.data.frame(df[,(names(df) %in% cols),drop=F]); ##this will silent become a vector when only one column!
    names(df)=cols;
    df;
  }else{
    df=as.data.frame(df[,(names(df) %in% cols),drop=F]); ##this will silent become a vector when only one column!
    df;
  }
}

keepNumeric=function(df){
  for(n in names(df)){
    if( !is.numeric(df[[n]])){     
      df[[n]]=NULL;
      message(n," removed");
    }
  } 
  df;
}

likeNames=function(df,pattern){
  names(df)[grep(pattern,names(df))] 
}
likeNotNames=function(df,pattern){
  names(df)[-grep(pattern,names(df))] 
}
notNames=function(df,notVector){
  names(df)[!(names(df) %in% notVector)]  
}

likeVector=function(v,pattern){
  v[grep(pattern,v)] 
}


likeNotVector=function(v,pattern){
  ##caution breaks when pattern matches nothing!
  v[-grep(pattern,v)] 
}

options(scipen=10)


cls=function() cat("\014");


ezvif=function(df,yvar,folds=5,trace=F,ignore=c()){
  require(VIF)
  require(cvTools);
  #returns selected variables using VIF and kfolds cross validation 
  
  if(nrow(df)!=sum(complete.cases(df))) {
    stop("NAs in df")
  }
  df=discard(df,ignore);
  df=ez.model.data.frame(df,yvar)
  f=cvFolds(nrow(df),K=folds);
  findings=list();
  for(v in names(df)){
    if(v==yvar)next;
    findings[[v]]=0; 
  }
  for(i in 1:folds){   
    if(trace) message("fold ",i);
    rows=f$subsets[f$which!=i] ##leave one out 
    y=df[rows,yvar];
    xdf=df[rows,names(df) != yvar]; #remove output var    
    if(trace) say("trying ",i,yvar,nrow(df),length(y)," subsize=",min(200,floor(nrow(xdf))));
    vifResult=vif(y,xdf,trace=trace,subsize=min(200,floor(nrow(xdf))))
    if(trace) print(names(xdf)[vifResult$select]);
    for(v in names(xdf)[vifResult$select]){
      findings[[v]]=findings[[v]]+1; #vote
    }
  }
  findings=(sort(unlist(findings),decreasing = T))    
  if(trace) print(findings[findings>0]); 
  return( c(yvar,names(findings[findings==findings[1]])) )  
}

#converts ezvif results into formula
ezformula=function(v,operator=' + '){
  return(as.formula(paste(v[1],'~',paste(paste0('`',v[-1],'`'),collapse = operator))))
}

ezezformula=function(v,operator=' + '){
  return((paste(v[1],'~',paste(v[-1],collapse = operator))))
}


ez.model.data.frame=function(df,yvar){
  if(nrow(df)!=sum(complete.cases(df))) {
    stop("NAs in df, may need to impute or just use complete.cases")
  }
  only1=names(df)[lapply(df, function(x) length(unique(x)))==1]
  x<-model.matrix(as.formula(paste(yvar,"~.")),data=discard(df,only1))
  x=x[,-1] ##remove intercept
  return(cbind(as.data.frame(x),df[,yvar,drop=F]))
}

##returns variables from lasso variable selection, use alpha=0 for ridge
##THIS DOES NOT HANDLE NA IN DATA FRAME!!!
ezlasso=function(df,yvar,folds=10,trace=F,alpha=1,weights=NULL){ #yvar='y'
  if(nrow(df)!=sum(complete.cases(df))) {
    stop("NAs in df, may need to impute or just use complete.cases")
  }
  x<-model.matrix(as.formula(paste(yvar,"~.")),data=df)
  
  x=x[,-1] ##remove intercept
  if(is.null(weights)){
    glmnet1<-glmnet::cv.glmnet(x=x,y=df[,yvar],type.measure='mse',nfolds=folds,alpha=alpha)
  }else{
    glmnet1<-glmnet::cv.glmnet(x=x,y=df[,yvar],type.measure='mse',nfolds=folds,alpha=alpha,weights = weights)
  }
  
  co<-coef(glmnet1,s = "lambda.1se")
  #print(co)
  inds<-which(as.vector(co)!=0)
  variables<-row.names(co)[inds]
  variables<-variables[!(variables %in% '(Intercept)')];
  return( c(yvar,variables));
}


glmnet.train=function(f,df,weights=NULL){
  require(glmnet)
  yvar=all.vars(f)[1];
  x<-model.matrix(f,data=df)
  x=x[,-1] ##remove intercept  
  if(is.null(weights)){
    m<-glmnet::cv.glmnet(x=x,y=df[,yvar])
  }else{
    m<-glmnet::cv.glmnet(x=x,y=df[,yvar],weights = weights)
  }
  ###
  co=coef(m);
  inds<-which(co!=0)
  p=as.vector(predict(m, newx = x, type = "response", s = 0.05));
  attr(m,'rsquared')=rsq(actual = df[,yvar],pred = p)
  attr(m,'adjusted.rsquared')=adj.rsq(actual = df[,yvar],pred = p,length(inds))
  ####
  attr(m,'yvar')=yvar;
  attr(m,'formula')=f;
  attr(m,'model.matrix.colnames')=colnames(x);
  m;
}

glmnet.summary=function(glmnet1){
  cat("Response: ")
  cat(as.character(attr(m,'yvar')));
  cat("\n");
  cat("Formula: ")
  cat(as.character(attr(m,'formula')));
  cat("\n");
  co=coef(glmnet1);
  inds<-which(co!=0)
  variables<-row.names(co)
  for(v in inds) {
    cat(sprintf("%55s\t\t%10.10f",variables[v],co[v]),"\n")
  }
  cat('rsquared=',attr(m,'rsquared')," cor=",(attr(m,'rsquared'))^0.5,"\n")
  cat('adjusted.rsquared=',attr(m,'adjusted.rsquared'),"\n")  
}


glmnet.predict=function(m,df,yvar=attr(m,'yvar')){  
  x<-model.matrix(as.formula(paste(yvar,"~.")),data=df)
  x=x[,attr(m,'model.matrix.colnames')];
  as.vector(predict(m, newx = x, type = "response", s = 0.05))
}


printCatRegressionResults=function(model,df=model$data,target=all.vars(model$terms)[1],title=paste(sys.call()),...){
  require(ROCR);
  print(title);
  print(summary(model))
  pr <- predict(model, df, type="response")  
  printCatRegressionResultsAP(df[,target],pr,title,...)
}

printCatRegressionResultsAP=function(act,pr,title=paste(sys.call(),collapse = ""),cutpoint=mean(act),show.baseline=F,busy=F){
  require(ROCR)
  message(title," with cutpoint of ",cutpoint)
  ###conf matrix
  cat(title," Confusion Matrix\n");
  print(table(actual=act, predicted=pr>cutpoint)) 
  ###
  if(length(unique(act))<2 || length(unique(pr))<2){
    print(summary(data.frame(act=act,pr=pr)))
    return(NA);
  }
  gdf=actualsVsPredictions(act,pr)
  if(!is.null(gdf)){
    if(busy){
      #if the next one booms, act needs to be 0,1 and pr continuous from 0 to 1 
      tryCatch({
        ##all perf
        ezplot1(gdf,xvar='avgp',type='b',title=paste(title,"Performance")  )
      },error=function(cond) { 
        message("ERR ALL PERF PLOT:",title," ERR:",cond," mean(act)=",(mean(act))," mean(pr)=",(mean(pr))) 
        print(summary(gdf))
        dev.off()
      });
    }
    tryCatch({
      ###Perf
      ezplot1(gdf,xvar='avgp',yvars = c('pop','avga'),type='b',title=paste(title,"Performance")  )
      abline(h=mean(act),col="gray")
    },error=function(cond) { 
      message("ERR POP PERF PLOT:",title," ERR:",cond," mean(act)=",(mean(act))," mean(pr)=",(mean(pr))) 
      print(summary(gdf))
      dev.off()
    });
    if(show.baseline){
      ###baseline
      tryCatch({
        gdf$rate=gdf$avga/mean(act)
        ezplot1(gdf,xvar='pop',yvars = c('rate'),type='b',title=paste(title," over Baseline"),ylab="rate",xlab="Population" )
        abline(h=1,col="gray")
      },error=function(cond) { 
        message("ERR baseline PLOT:",title," ERR:",cond," mean(act)=",(mean(act))," mean(pr)=",(mean(pr))) 
        dev.off()
      });
    }
  }
  tryCatch({
    ###lift chart
    require(gains)
    plot(  gains(actual=act, predicted=pr, optimal=TRUE),       main=paste0(title," Lift Chart (mean=",round(mean(act)*100,1),"%)"))
    abline(h=mean(act),col="gray")
    grid()
    ###histo
    h=hist(pr, breaks=20,main = paste(title," Histogram") )
    hist(pr[act>=1], col="green", add=TRUE,breaks = h$breaks)
  },error=function(cond) { 
    message("ERR lift/histo PLOT:",title," ERR:",cond," mean(act)=",(mean(act))," mean(pr)=",(mean(pr))) 
    dev.off()
  });
  ###PR
  tryCatch({
    plot(performance(prediction(pr,act),"ppv","tpr"),main=paste(title,'PR Curve'))  
  },error=function(cond) { 
    message("ERR pr curve PLOT:",title," ERR:",cond," mean(act)=",(mean(act))," mean(pr)=",(mean(pr))) 
    dev.off()
  });
  ###KS SCORE
  ks=NA
  tryCatch({
    ks=ks.scoreAP(act,pr,title)
  },error=function(cond) { 
    message("ERR ks.scoreAP PLOT:",title," ERR:",cond," mean(act)=",(mean(act))," mean(pr)=",(mean(pr))) 
    dev.off()
  });
  ks;
} 


accumulate.slowly=function(df,xvar,by=NULL){
  #returns entire df, should be changed to lists or vectors
  if(!is.null(by)) df=df[order(df[,by]),];
  acc=0;
  for(i in 1:nrow(df)){
    acc=acc+df[i,xvar];
    df[i,paste0(xvar,'.summed')]=acc;
  }
  df;
}

bucketize=function(x,buckets=10) round(x/buckets)*buckets+buckets/2;
#the bucket value is roughly equal to the [min,median of the buckets,max]
tilize=function(x,tiles=10) quantile(x,round(tiles*(rank(x)/length(x)))/tiles);

#this graphs yvar by xvar
graphBunched=function(df,xvar,yvar,FUN=mean){
  bunch=df
  bunch[,xvar]=tilize(bunch[,xvar])
  bunch=aggregate(as.formula(paste(yvar," ~ ",xvar)),bunch,FUN)
  bunch=bunch[order(bunch[,xvar]),]  
  ezplot1(bunch,xvar=xvar,yvars=yvar,title=paste(yvar,"by",xvar),type='l')
  bunch;
}


rmGlobal=function() rm(list = ls(all = TRUE,envir = globalenv()),envir = globalenv());


##this takes a numeric target field of discrete values and tries to make uniform.
resampleEven=function(ddf,target){
  ddf$.count=rep(1,nrow(ddf))
  w=aggregate(as.formula(paste(".count ~ ",target)),ddf,length)
  w$.count=(1/(w$.count/max(w$.count)))
  w$.count=w$.count/sum(w$.count)
  mapIt=setNames(w$.count,as.character(w[,target]))
  iopull=mapIt[as.character(ddf[,target])];
  reddf=ddf[sample(nrow(ddf),nrow(ddf),replace=T,iopull),]
  reddf$.count=NULL
  reddf;
}

getWeights=function(ddf,target,resultdf=ddf){  ##returns vector
  ##this takes a numeric target field of discrete values and tries to make weights vector.
  ##this will evenly weight all distinct values.
  ##this builds the weight vector based on the stats of ddf but for resultdf
  if(!is.all.whole.numbers(ddf[,target])) stop(paste(target,'is not whole numbers'))
  ddf$.count=rep(1,nrow(ddf))
  ddf$.x=ddf[,target]
  w=aggregate(.count ~ .x,ddf,length)
  w$.count=ceiling(1/(w$.count/max(w$.count)))
  mapIt=setNames(w$.count,as.character(w$.x))
  IOwates=mapIt[as.character(resultdf[,target])];
  d=as.integer(IOwates)
  d[is.na(d)] <- 0
  return(d);  
}


##this takes a numeric target field of discrete values and tries to make weights vector.
##this will  weight all distinct values to match ddf.
##this builds the weight vector based on the stats of ddf but for resultdf
getMatchingWeights=function(ddf,target,resultdf=ddf){  ##returns vector
  if(!is.all.whole.numbers(ddf[,target])) stop(paste(target,'is not whole numbers'))
  ddf$.count=rep(1,nrow(ddf))
  ddf$.x=ddf[,target]
  w=aggregate(.count ~ .x,ddf,length)
  mapIt=setNames(w$.count,as.character(w$.x))
  IOwates=mapIt[as.character(resultdf[,target])];
  d=as.integer(IOwates)
  d[is.na(d)] <- 0
  return(d);  
}

# ##slow but works
# ##faster but not as good: alive2=alive[sample(nrow(alive),nrow(died),prob = getMatchingWeights(died,'age',alive),replace=T),]
# same.sample=function(srcdf,destdf,column,trace=T,balance.ratio=1,under.sample=T){
#   adf=NULL;
#   for(a in unique(sort(srcdf[[column]]))){
#     if(under.sample){
#       pull=destdf[ destdf[[ column ]] ==a,,drop=FALSE];
#       poolsize=nrow(pull)
#       needed=length(which(srcdf[[column]]==a))*balance.ratio
#       if(trace){
#         message('grabbing for ',a,' got ',poolsize,' need ',needed)
#       }
#       adf=rbind(adf,pull[sample(poolsize,needed,replace=needed>poolsize),,drop=FALSE]);
#     }
#   }
#   adf;
# }

##slow but works
##faster but not as good: alive2=alive[sample(nrow(alive),nrow(died),prob = getMatchingWeights(died,'age',alive),replace=T),]
##r=same.sample2(alive,died,'age') #reshapes died to alive age shape
same.sample=function(matchdf,pullFromDf,column, neededCountDf=matchdf,trace=T,balance.ratio=1){
  adf=NULL;
  for(a in unique(sort(matchdf[[column]]))){
    pull=pullFromDf[ pullFromDf[[ column ]] ==a,,drop=FALSE];
    poolsize=nrow(pull)
    needed=length(which(neededCountDf[[column]]==a))*balance.ratio
    if(trace){
      message('grabbing for ',a,' got ',poolsize,' need ',needed)
    }
    adf=rbind(adf,pull[sample(poolsize,needed,replace=needed>poolsize),,drop=FALSE]);
  }
  adf;
}





tidyit=function(df,scale=T) {
  require(stats)
  for(n in names(df)){
    if(scale) df[[n]]=as.vector(((df[[n]]-min(df[[n]]))/(max(df[[n]])-min(df[[n]]))));
    df[[n]]=ksmooth(1:nrow(df),df[[n]],kernel="normal",bandwidth = 10)$y
  }
  df;
}

ezsmooth=function(xvar,yvar,df){
  #quickly does a lowess smooth on the data
  result=lowess(df[,xvar],df[,yvar]);
  df[,xvar]=result$x;
  df[,yvar]=result$y;
  df;
}

#ezsmooth1d=function(v,width=10) ksmooth(v,1:(length(v)),kernel="normal",bandwidth = width,n.points=length(v))$y
# ezsmooth1d=function(v) {
#   lowess(v);  
# }



##tries to minimize the skewness of the varable
findBestBoxCoxTarget=function(df,yvar,lower=-1,upper=2,step=0.25,use.offset=F){
  require(moments)
  df=df[order(df[,yvar]),];  
  target=df[,yvar];  
  offset=0;
  if(use.offset)  offset=(1-min(target));
  bestMetric=abs(skewness(target));
  if(is.na(bestMetric)){
    stop(paste("findBestBoxCoxTarget went na",yvar));
  }
  besti=1;
  say(yvar,besti,bestMetric);
  #say("forecast::BoxCox.lambda",forecast::BoxCox.lambda(target));
  for(i in (seq(lower,upper,step))){
    target=df[,yvar];
    if(i==1){
      next;
    }else if(i==0){
      target=log(target+offset);
    }else{      
      target=((target+offset)^i - 1.0)/i;
    }
    r=abs(skewness(target));
    say(yvar,i,r);
    if(!is.na(r) && r<bestMetric){
      bestMetric=r;
      besti=i;
    }
  }
  return(c(lambda=besti,abs.skew=bestMetric,offset=offset));
}


##compute the rank of the target and determines the best box cox function for that target
findBestBoxCoxTargetByRank=function(df,yvar,lower=-1,upper=2,step=0.25){
  df=df[order(df[,yvar]),];  
  target=df[,yvar];
  targetRank=rank(target);
  bestRsq=rsq(target,targetRank);
  if(is.na(bestRsq)){
    stop(paste("findBestBoxCoxTarget r2 is na",yvar));
  }
  besti=1;
  say(yvar,besti,bestRsq);
  #say("forecast::BoxCox.lambda",forecast::BoxCox.lambda(target));
  for(i in (seq(lower,upper,step))){
    target=df[,yvar];
    if(i==1){
      next;
    }else if(i==0){
      target=log(target);
    }else{
      #((Math.pow(x * mult + lambda2, bc) - 1.0) / bc);
      target=(target^i - 1.0)/i;
    }
    r=abs(rsq(target,targetRank));
    say(yvar,i,r,moments::skewness(target));
    if(!is.na(r) && r>bestRsq){
      bestRsq=r;
      besti=i;
    }
  }
  return(c(besti,bestRsq));
}

makeNegUnderscore <- function (besti) {
  ifelse(besti<0,paste0('_',abs(besti)),besti)
}

addLadders=function(df,yvar,xvars=names(df),ignore=c(),lower=-1,upper=3,step=0.1,rename=T,
                    rows=getTestTrainRows(df),prune=T,trace=T,use.reg=T,use.skew=F){
  #require(e1071)
  y=df[,yvar]
  is.logistic=(length(unique(y))==2 && min(y)==0 && max(y)==1)
  message(is.logistic)
  for(xvar in xvars){
    if(xvar == yvar) next;
    if(xvar %in% ignore) next; 
    x=df[,xvar];  
    if(!any(is.numeric(x))    ) next;
    if(is.na(min(x))) next;
    if(min(x)==max(x)) next;
    if(min(x)==0 && max(x)==1) next; #dummie detection    
    presence=mean(!is.na(x))
    if(presence==0) next;
    
    test=!is.na(x) & !is.na(y)    
    
    curNewXVar=xvar	
    curNewX=x
    if(use.skew){
      baseBest=curBest=(e1071::skewness(x[test]) * 1/presence)
      testIt=function(suffix,newx){
        a=(e1071::skewness(newx[test]) * 1/presence)
        if(a<(curBest)){
          curBest <<- a;
          curNewXVar <<- paste0(xvar,suffix)
          curNewX <<- newx
        }
      }
    }else if(is.logistic){
      if(use.reg){
        baseBest=curBest=(logLik(glm(y[test]~x[test],family="binomial")) * 1/presence)
        testIt=function(suffix,newx){
          a=(logLik(glm(y[test]~x[test],family="binomial")) * 1/presence)
          catln(a,'vs',curBest,' for ',xvar,suffix)
          if(a>(curBest)){
            curBest <<- a;
            curNewXVar <<- paste0(xvar,suffix)
            curNewX <<- newx
          }
        }
      }else{
        baseBest=curBest=(t.test(x[test],y[test])$statistic^2 * 1/presence)
        testIt=function(suffix,newx){
          a=(t.test(newx[test],y[test])$statistic^2 * 1/presence)
          if(abs(a)<abs(curBest)){
            curBest <<- a;
            curNewXVar <<- paste0(xvar,suffix)
            curNewX <<- newx
          }
        }
      }
    }else{
      baseBest=curBest=(cor(x[test],y[test])*presence)
      testIt=function(suffix,newx){
        a=cor(newx[test],y[test])*presence
        if(abs(a)>abs(curBest)){
          curBest <<- a;
          curNewXVar <<- paste0(xvar,suffix)
          curNewX <<- newx
        }
      }
    }
    #     4.  Square
    testIt('_sqr',x^2);
    #     7.  cube
    testIt('_cube',x^3);
    testIt('_asinh',asinh(x));
    if(min(x)>=1){
      #     1.  Original
      #     2.  Square root
      testIt('_sqrtP',sqrt(x))
      #     3.	Natural log
      testIt('_lnP',log(x)   ) 
      #     5.	Cube root
      testIt('_crootP',(x)^(1/3))
      #     6.	Negative reciprocal
      testIt('_nrP',-1/(x))
    }else if(min(x)>=0  ){
      #     1.  Original
      #     2.  Square root
      testIt('_sqrt0',sqrt(x+1))
      #     3.  Natural log
      testIt('_ln0',log(x+1))
      #     5.	Cube root
      testIt('_croot0',(x+1)^(1/3))
      #     6.	Negative reciprocal
      testIt('_nr0',-1/(x+1))
    }else{ #less than 0
      #     1.  Original
      if(sum(x<1)/length(x)>0.05){ ##more than 5%
        #     3.  Natural log
        testIt('_lnM',ifelse(x<0,-1,1)*log(abs(x)+1))
        #     6.  Negative reciprocal
        if(max(x)>2){
          testIt('_rp1M',1/(ifelse(abs(x)<0.1,0.1,x)))  
        }        
      }else{
        #     2.  Square root
        testIt('_sqrtN',sqrt(ifelse(x<1,1,x)))
        #     3.  Natural log
        testIt('_lnN',log(ifelse(x<1,1,x)))
        #     5.  Cube root
        testIt('_crootN',(ifelse(x<1,1,x))^(1/3)  )
        #     6.  Negative reciprocal
        testIt('_nrN',-1/(ifelse(x<1,1,x)))
      }        
    }    
    if(curNewXVar!=xvar){
      catln('//',xvar,curNewXVar,curBest,baseBest)
      if(prune)  df[[xvar]]=NULL
      df[[curNewXVar]]=curNewX
    }
  }##end for
  if(20+15*length(names(df))>nrow(df)){
    warning(paste("number of rows in df is dangerously low")); 
  }
  df;
}



addLaddersForPrediction=function(df,yvar='',xvars=names(df),ignore=c(),lower=-1,upper=3,step=0.1,rename=T,
                                 rows=getTestTrainRows(df)){
  for(xvar in xvars){
    if(xvar == yvar) next;
    if(xvar %in% ignore) next;        
    x=as.double( df[,xvar]);  
    ndf=data.frame(preload=1:nrow(df));
    if(is.na(min(x))) next;
    #     1.  Original
    #     2.  Square root
    ndf[,paste0(xvar,'_sqrtP')]=sqrt(x)
    #     3.  Natural log
    ndf[,paste0(xvar,'_lnP')]=log(x)
    #     4.	Square
    ndf[,paste0(xvar,'_sqrP')]=x*x
    #     5.	Cube root
    ndf[,paste0(xvar,'_crootP')]=(x)^(1/3)
    #     6.	Negative reciprocal
    ndf[,paste0(xvar,'_nrP')]=-1/(x)
    ###################################################
    #     1.  Original
    #     2.  Square root
    ndf[,paste0(xvar,'_sqrt0')]=sqrt(x+1)
    #     3.  Natural log
    ndf[,paste0(xvar,'_ln0')]=log(x+1)
    #     4.	Square
    ndf[,paste0(xvar,'_sqr')]=x*x
    #     4.	Square
    ndf[,paste0(xvar,'_cube')]=x*x*x
    #     5.	Cube root
    ndf[,paste0(xvar,'_croot0')]=(x+1)^(1/3)
    #     6.	Negative reciprocal
    ndf[,paste0(xvar,'_nr0')]=-1/(x+1)
    #####################################################
    #     1.  Original
    #     4.  Square
    ndf[,paste0(xvar,'_sqrN')]=x*x      
    ######################################################
    #     3.  Natural log
    ndf[,paste0(xvar,'_lnM')]=ifelse(x<0,-1,1)*log(abs(x)+1)
    #     6.  Negative reciprocal
    ###########
    ndf[,paste0(xvar,'_rp1M')]=1/(ifelse(abs(x)<0.1,0.1,x))  
    
    #########################
    #     2.  Square root
    ndf[,paste0(xvar,'_sqrtN')]=sqrt(ifelse(x<1,1,x))
    #     3.  Natural log
    ndf[,paste0(xvar,'_lnN')]=log(ifelse(x<1,1,x))
    #     5.  Cube root
    ndf[,paste0(xvar,'_crootN')]=(ifelse(x<1,1,x))^(1/3)  
    #     6.  Negative reciprocal
    ndf[,paste0(xvar,'_nrN')]=-1/(ifelse(x<1,1,x))
    ndf$preload=NULL
    if(!is.null(ndf)){
      df=cbind(df,ndf); ##keep columns that are good    
      if('ndf' %in% names(df) ) stop("a data.frame become a vector again");
    }else{
      message("NONE TO ADD!!!!!!!!!!!!!!!!!!!!!!!!");
    }
  }
  df;
}


##compute the rank of the target and determines the best box cox function for that target
findBestBoxCoxX=function(df,yvar,xvars=names(df),ignore=c(),lower=-1,upper=3,step=0.1,rename=T){
  #http://pareonline.net/getvn.asp?v=15&n=12
  #Osborne (2002) anchoring the minimum value in a distribution at exactly 1.0
  bestRsqs=c();
  target=df[,yvar];
  for(xvar in xvars){
    if(xvar == yvar) next;
    if(xvar %in% ignore) next;        
    x=df[,xvar];
    if(length(unique(x))<3) next; #only 2 values or less!
    #let's anchor close to 1.0 http://pareonline.net/getvn.asp?v=8&n=6
    offset=(1-min(x));
    bestRsq=abs(rsq(target,x)); #baseline rsq, unaltered x
    if(is.na(bestRsq)) bestRsq=0;
    besti=1;
    for(i in (seq(lower,upper,step))){
      x=df[,xvar];
      x=x+offset;
      if(i==1){
        next;
      }else{
        #was log or x=(x^i - 1.0)/i;
        x=forecast::BoxCox(x,i);        
      }
      if(any(is.na(x))) next;
      r=abs(adj.rsq(x,target,1));
      if(is.na(r)) next;
      if(r>bestRsq){
        bestRsq=r;
        besti=i;
      }
    }
    new.xvar=paste0('bc_',xvar,'_p',makeNegUnderscore(offset),'_',makeNegUnderscore(besti));
    bestRsqs=c(bestRsqs,bestRsq);
    if(rename){      
      say("BEST",xvar,yvar,"lambda=",besti,"rsq=",signif(bestRsq,2),new.xvar);
    }else{
      say("BEST",xvar,yvar,"lambda=",besti,"rsq=",signif(bestRsq,2));
    }
    if(besti!=1){
      if(rename){
        df[,new.xvar]=
          forecast::BoxCox(df[,xvar]+offset,besti);
        df[,xvar]=NULL;        
      }else{
        df[,xvar]=forecast::BoxCox(df[,xvar]+offset,besti);
      }
    }
  }    
  say('meanRsq',mean(bestRsqs),'sumRsq',sum(bestRsqs),'bestRsq',max(bestRsqs),'worstRsq',min(bestRsqs))
  df;
}


##compute the rank of the target and determines the best box cox function for that target
findBestPolyX=function(df,yvar,xvars=names(df),ignore=c(),lower=2,upper=6,step=1,rename=T,trace=F){
  target=df[,yvar];
  for(xvar in xvars){
    if(xvar == yvar) next;
    if(xvar %in% ignore) next;        
    x=df[,xvar];
    centering=signif(-mean(x),4); 
    bestRsq=abs(rsq(target,x)); #baseline unaltered
    if(is.na(bestRsq)) bestRsq=0;
    besti=1;
    bestx=x;
    tdf=data.frame(x1=1:nrow(df));
    tdf[,yvar]=target;
    formulaStr=paste(yvar,"~");
    for(i in (seq(1,upper,step))){
      x=df[,xvar];
      x=x+centering;
      newXterm=paste0(xvar,'x',i);
      tdf[,newXterm]=x^i;
      formulaStr=paste(formulaStr,newXterm,'+');
      tlm=lm(as.formula(paste(formulaStr,'1')),tdf);
      tlm=stepAIC(tlm,trace=0);
      x=predict(tlm);
      if(any(is.na(x))) next;
      r=abs(adj.rsq(x,target,i));
      if(is.na(r)) next;
      if(r>bestRsq){        
        if(trace) print(summary(tlm))
        bestRsq=r;
        besti=i;
        bestx=x;
        if(trace) say("BETTER adj.rsq",xvar,yvar,"poly=",besti,"rsq=",signif(bestRsq,10));
      }else{
        if(i>1) break; #give up
      }
    }
    new.xvar=paste0('poly_',xvar,'_p',makeNegUnderscore(centering),'_',makeNegUnderscore(besti));
    if(rename){
      say("BEST adj.rsq",xvar,yvar,"poly=",besti,"rsq=",signif(bestRsq,2),new.xvar);
    }else{
      say("BEST adj.rsq",xvar,yvar,"poly=",besti,"rsq=",signif(bestRsq,2));
    }
    if(besti!=1){
      if(rename){
        df[,new.xvar]=bestx;
        df[,xvar]=NULL;        
      }else{
        df[,xvar]=bestx;
      }
    }
  }  
  df;
}

###
##compute the rank of the target and determines the best box cox function for that target
findBestBoxCoxPolyX=function(df,yvar,xvars=names(df),
                             ignore=c(),upper=4,step=1,rename=T,trace=F,
                             specials=c('loglevel','loglog'),IMPROV=1.001,rows=getTestTrainRows(df)){
  bestRsqs=c();  
  #improv is the minimum amount of improvement in rsquared to bother with transform
  target=df[,yvar];
  for(xvar in xvars){
    if(xvar == yvar) next;
    if(xvar %in% ignore) next;        
    x=df[,xvar];    
    if(length(unique(x))<3) next; #only 2 values or less!
    new.xvar=xvar;
    #let's anchor close to 1.0 http://pareonline.net/getvn.asp?v=8&n=6
    offset=(1-min(x));    
    centering=signif(-mean(x),4); 
    bestRsq=abs(rsq(target,x)); #baseline unaltered
    if(is.na(bestRsq)) bestRsq=0;
    baseRsq=bestRsq;
    better=FALSE;
    bestx=x;
    ##for proportional data    
    if(min(x)==0 && max(x)==100){
      x=x/100; ##try proportional
    }
    if(min(x)>=0 && max(x)<=1){
      say("proportional",xvar);
      epsilonA=min(abs(0-x[x>0]))/2;
      epsilonB=min(1-x[x<1])/2.0;
      x=ifelse(x==0,epsilonA,ifelse(x==1,epsilonB,x))
      x=logit(x);
      if(all(!is.na(x))) {        
        r=abs(adj.rsq(x,target,1));
        if(!is.na(r)){
          if(r>(bestRsq*IMPROV)){
            bestRsq=r;
            better=T
            bestx=x;
            new.xvar=paste0(xvar,'_logit','a',makeNegUnderscore(epsilonA),'b',makeNegUnderscore(epsilonB));
            if(trace) say("BETTER",xvar,yvar,"rsq=",signif(bestRsq,2),new.xvar);
          }
        }
      }
    }
    ##for boxcox
    for(tryoff in unique(c(0,offset,(0-min(x))))){
      for(i in c(1/2,0,2,1/3,-1)){ #(seq(-1,2,0.1))){
        if(i==1 && tryoff==0){
          next;
        }else{
          x=df[,xvar];
          x=x+tryoff;   
          #was log or x=(x^i - 1.0)/i;
          ##x=forecast::BoxCox(x,i);        
          bias=ifelse(x<=0,1,0);
          if(i==0){
            x=ifelse(x<=0,0,log(x)); ##this may produce false warning
          }else{            
            x=ifelse(x<=0,0,x^i);
          }          
        }
        if(any(is.na(x))) {
          say("NaNs",i,tryoff,xvar);
          next;
        }
        tdf=data.frame(target=target,x=x,bias=bias);
        if(max(bias)==1){
          tlm=lm(target~x+bias+1,tdf[rows$train,]);          
        }else{
          tlm=lm(target~x+1,tdf[rows$train,]);
        }         
        if(length(tlm$coefficients) > tlm$rank){          
          print(summary(tlm))
          say(xvar,'i=',i,'tro=',tryoff,length(tlm$coefficients)," > ",tlm$rank)
          hist(x)
          print(length(x));
          print(length(bias));
          print(length(unique(x)));
          print(length(unique(bias)));
          stop("rank deficient pow",xvar,i,' ',tryoff);
        }
        x=predict(tlm,tdf);
        if(any(is.na(x))) next;        
        r=abs(adj.rsq(x[rows$test],target[rows$test],length(coef(tlm))-1));
        if(is.na(r)) next;
        if(r>(bestRsq*IMPROV)){
          bestRsq=r;
          better=T
          bestx=x;          
          new.xvar=paste0(xvar,'_pow','_p',makeNegUnderscore(tryoff),'_',makeNegUnderscore(i));
          summary(tlm)
          say(new.xvar,"COEF",coef(tlm));
          if(trace) say("BETTER",xvar,yvar,"pow=",i,"rsq=",signif(bestRsq,2),new.xvar);
        }else{
          if(trace) say("NO BETTER",xvar,yvar,"pow=",i,"rsq=",signif(r,2),'pow');
        }
      }  
    }
    ##for log level    
    for(special in c('loglevel','loglog')){
      x=df[,xvar];
      x=x+offset;
      yoffset=(1-min(target));   
      y=log(target+yoffset);
      if(!any(is.na(y)) && !any(is.na(x))){
        if(special=='loglevel'){ #exponential regression 
          m.lm=lm(y~x);
          a=exp(m.lm$coefficients[1])
          b=exp(m.lm$coefficients[2])                      
          x=(a*b^x)-yoffset;                  
        }else if(special=='loglog'){ #power regression http://www.real-statistics.com/regression/power-regression/
          m.lm=lm(y~I(log(x)));
          a=exp(m.lm$coefficients[1])
          b=(m.lm$coefficients[2])                      
          x=(a*x^b)-yoffset;      
        }else{
          stop("not special",special); 
        }          
        #         px=exp(predict(m.lm))-yoffset;
        #         say('rmse between ',special,' and equation',rmse(x,px))
        r=abs(adj.rsq(x,y,2)); #penalty
        if(!is.na(r) && r>(bestRsq*IMPROV)){
          bestRsq=r;
          better=T
          bestx=x
          new.xvar=paste0(xvar,'_',special,'_px',makeNegUnderscore(offset),
                          '_py',makeNegUnderscore(yoffset),
                          '_a',makeNegUnderscore(a),
                          '_b',makeNegUnderscore(b));
          say(new.xvar,"COEF",coef(m.lm));
          if(trace) say("BETTER",xvar,yvar,"rsq=",signif(bestRsq,2),new.xvar);
        }
      }
    }
    ##for poly
    tdf=data.frame(x1=1:nrow(df));
    tdf[,yvar]=target;
    formulaStr=paste(yvar,"~");
    for(i in (seq(1,upper,step))){ 
      x=df[,xvar];
      x=x+centering;
      newXterm=paste0(xvar,'x',i);
      tdf[,newXterm]=x^i;
      formulaStr=paste(formulaStr,newXterm,'+');      
      trainer=tdf[rows$train,];
      tlm=lm(as.formula(paste(formulaStr,'1')),trainer); 
      tlm=stepAIC(tlm,trace=0);
      if( length(tlm$coefficients)> tlm$rank){
        print(summary(tlm))
        stop("rank deficient",xvar,i);
      }
      x=predict(tlm,tdf);
      if(any(is.na(x))) next;
      r=abs(adj.rsq(x[rows$test],target[rows$test],i));
      if(is.na(r)) next;
      if(r>(bestRsq*IMPROV)){        
        if(trace) print(summary(tlm))
        bestRsq=r;
        better=T
        bestx=x;
        new.xvar=paste0(xvar,'_poly','_p',makeNegUnderscore(centering),'_',makeNegUnderscore(i));
        say(new.xvar,"COEF",coef(tlm));
        if(trace) say("BETTER",xvar,yvar,"poly=",i,"rsq=",signif(bestRsq,10));
      }else{
        if(i>1) break; #give up
      }
    }        
    bestRsqs=c(bestRsqs,bestRsq);
    say("BEST",better,yvar,round(bestRsq/baseRsq,2)-1,signif(baseRsq,2),signif(bestRsq,2),new.xvar);
    if(better){
      if(rename){
        df[,new.xvar]=bestx;
        df[,xvar]=NULL;        
      }else{
        df[,xvar]=bestx;
      }
    }
  }  
  say('meanRsq',mean(bestRsqs),'sumRsq',sum(bestRsqs),'bestRsq',max(bestRsqs),'worstRsq',min(bestRsqs))
  df;
}

###





copyToPaste=function(df){
  writeClipboard(knitr::kable(df))
}


multihist=function(inlist,title=NULL,legendloc=NULL,scaled=F,standardized=F,type='b',...){
  ##takes a list or a dataframe
  ##there is a plotting bug in which if two things have identical distros only one will be visible!
  ##barplot(table(df$householdsizeactual)/length(df$householdsizeactual));grid();title('workitem histo')
  bigVector=c();
  for(n in names(inlist)){
    if(class(inlist[[n]])=='factor') next;
    if(standardized) inlist[[n]]=(inlist[[n]]-mean(inlist[[n]],na.rm = T))/sd(inlist[[n]],na.rm = T)
    bigVector=c(bigVector,inlist[[n]])
  }
  brk=hist(bigVector,plot=F)$breaks
  built=list();
  for(n in names(inlist)){
    if(class(inlist[[n]])=='factor') next;
    h=hist(inlist[[n]],plot = F,breaks=brk)
    if(scaled) {
      built[[n]]=data.frame(mids=h$mids,counts=100*h$counts/sum(h$counts))
    }else{
      built[[n]]=data.frame(mids=h$mids,counts=h$counts)
    }
    built[[n]][built[[n]]<=0]=NA
  }
  if(is.null(title))  title=paste('histogram of ',paste(names(inlist),collapse = ', '));
  ezplot4(built,xvar='mids',yvars='counts',type=type,title=title,ylab=ifelse(scaled,'percent','count'),legendloc=legendloc,...)
}

multihist.sideways=function(inlist,title=NULL,legendloc=NULL,scaled=F,type='b', 
                            col=c("red", "orange", "blue", "cyan", 
                                  "green", "lightgreen", "violet", 
                                  "pink", "black", "brown", "gray","magenta","yellow"),
                            ...){
  ##takes a list or a dataframe
  if(is.null(names(inlist))) stop("must have names");
  spot='topleft'
  colused=c();
  labels=c();
  ltys=c();
  pchs=c();
  loop=0; 
  for(n in names(inlist)){
    loop=loop+1 
    uc=col[(loop%%length(col))+1]
    colused=c(colused, uc);
    ltys=c(ltys,ifelse(type=='p',0,1)); 
    pchs=c(pchs,loop %% 25);
    labels=c(labels,n);
  }
  first=T
  plot(NULL,xlim=c(0,1),ylim=c(min(df,na.rm = T),max(df,na.rm=T)),ylab='values',xlab='rank')
  grid()
  legend(spot,y=NULL,labels,lty=ltys,pch=pchs,lwd=c(2.5,2.5),col=colused,
         horiz=F,
         x.intersp=0,xjust=0,yjust=0   )
  loop=0
  for(n in names(inlist)){
    loop=loop+1
    y=sort(inlist[[n]])
    x=1:length(y)
    x=x/max(x)
    print(length(x))
    print(length(y))
    points(x,y,type='b',col=colused[loop],pch=pchs[loop])
    first=F
  }
  if(is.null(title))  title=paste('rank of ',paste(names(inlist),collapse = ', '));
  title(title)  
}
#multihist.sideways(df)

getTestTrainRows <- function (df, brk=0.7) {
  s=sample(nrow(df),nrow(df));
  trainRows=s[1:(floor(length(s)*brk))];
  testRows=s[(floor(length(s)*brk+1)):length(s)];
  return(list(train=trainRows,test=testRows));
}
splitTrainTest=function(df,brk=0.7){
  rows=getTestTrainRows(df,brk);
  dftrain=df[rows$train,];
  dftest=df[rows$test,];
  say("dftrain",nrow(dftrain),"dftest", nrow(dftest))
  return( list(train=dftrain,test=dftest));
}

is.even <- function(x) trunc(x) %% 2 == 0



overdispersion=function(m){
  #source everyday R, page 239
  actuals=m$y
  z=(actuals-m$fitted.values)/sqrt(m$fitted.values);
  overdispersion.factor=sum(z^2)/m$df.residual;
  #if overdispersion.factor>=2 indictates overdispersion
  #high p values ~1 indicate significant overdispersion
  return(list(overdispersion.factor=overdispersion.factor,
              overdispersed=overdispersion.factor>=2,
              p.value=pchisq(sum(z^2),m$df.residual)))
}


goodness.of.fit <- function (m) {
  #tests to see if the whole model is useless. 
  #Ho is the model is useless. low p-value then Ho must go!
  p.value=1 - pchisq(summary(m)$deviance, 
                     summary(m)$df.residual)
  return(list(gof.p.value=p.value,fitted=p.value<0.05));       
}

#http://stackoverflow.com/questions/2547402/standard-library-function-in-r-for-finding-the-mode
Mode <- function(x) {
  ux <- unique(x)
  ux[which.max(tabulate(match(x, ux)))]
}

#http://stackoverflow.com/questions/2547402/standard-library-function-in-r-for-finding-the-mode
estimate_mode <- function(x) {
  d <- density(x)
  d$x[which.max(d$y)]
}



breakPointMaximizer=function(act,prd){
  #act must be whole numbers (think of as discrete)
  #this is experimental, the theory was that there may be better rounding points besides 0.5
  #finds the best breakpoints to convert floating point prd to integer actuals
  #by maximizing f1 score        
  df=data.frame(act=act,prd=prd,orig=prd);
  print(summary(df));
  df[df$prd<min(act),'prd']=min(act); ##handle lower outlier
  df[df$prd>max(act),'prd']=max(act); ##handle upper outlier
  print(head(df))
  breaks=c();
  for(i in seq(min(act),max(act)-1)){
    bestf1=0;
    breaks[i]=i+0.5;
    save=df$prd;
    for(decimal in seq(0.1,1,0.1)){
      df$prd=ifelse(df$prd>=i & df$prd<i+decimal,i,df$prd);      
      head(df)
      #f1=(2*tp)/(2*tp+fp+fn)
      tp=nrow(df[df$prd==i & df$act==i,]);        
      fp=nrow(df[df$prd==i & df$act!=i,]);
      fn=nrow(df[df$prd!=i & df$act==i,]);
      f1=(2*tp)/(2*tp+fp+fn)
      say(i,decimal,f1,tp,fp,fn)
      df$prd=save;##restore
      if(f1>bestf1){
        bestf1=f1;
        breaks[i]=i+decimal;          
      }
      #break;
    }
    df$prd=ifelse(df$prd>=i & df$prd<breaks[i],i,df$prd); #move 2 to 2.X down
    if(i>min(act)){
      df$prd=ifelse(df$prd>=breaks[i-1] & df$prd<=i,i,df$prd); #move 1.w to 2.0 up
    }
  }    
  print(breaks);
  return(df);
}

calcF1Scores=function(act,prd){
  #treats the vectors like classes
  #act and prd must be whole numbers
  if(!(is.all.whole.numbers(act) && is.all.whole.numbers(prd))) stop("calcF1Score needs whole numbers");
  df=data.frame(act=act,prd=prd);
  scores=list();
  for(i in seq(min(act),max(act))){
    tp=nrow(df[df$prd==i & df$act==i,]);        
    fp=nrow(df[df$prd==i & df$act!=i,]);
    fn=nrow(df[df$prd!=i & df$act==i,]);
    f1=(2*tp)/(2*tp+fp+fn)
    scores[[i]]=f1;
  }      
  print(scores)
  return(scores);
}



#require(qualityTools)


dotPlot2=function (x, group, xlim, ylim, col, xlab, ylab, pch, cex, breaks, 
                   stacked = TRUE, main='',...) 
{ ##bug fixed version from qualityTools
  DB = F
  pch.size = "O"
  grouped = TRUE
  parList = list(...)
  if (missing(xlab)) 
    xlab = deparse(substitute(x))
  x = x[!is.na(x)]
  if (missing(xlim)) 
    xlim = range(x)
  if (missing(ylim)) 
    ylim = c(0, 1)
  if (missing(ylab)) 
    ylab = ""
  if (missing(cex)) 
    cex = 1
  if (missing(group)) 
    group = rep(1, length(x))
  if (length(unique(group)) == 1) 
    grouped = FALSE
  if (missing(pch) || length(unique(group)) > length(pch)) 
    pch = 1:length(unique(group))
  if (missing(col) || length(unique(group)) > length(col)) 
    col = 1:length(unique(group))
  if (missing(breaks)) {
    plot(1, 1, xlim = xlim, ylim = ylim, type = "n", axes = T, 
         cex = cex, xlab = xlab, ylab = ylab,...)
    slotSizeX = strwidth(pch.size, units = "user", cex = cex)
    if (DB) 
      print(paste("slotSizeX:", slotSizeX))
    span = diff(range(x))
    temp1 = ppoints(2 * ceiling(span/slotSizeX))
    temp2 = numeric(length(temp1) + 2)
    temp2[2:(length(temp1) + 1)] = temp1
    temp2[1] = temp2[1] - 1.01 * diff(c(temp1[1], temp1[2]))
    temp2[length(temp2)] = rev(temp1)[1] + 1.01 * diff(c(temp1[1], 
                                                         temp1[2]))
    temp2 = temp2 * span + min(x)
    temp = min(x) + ppoints(span/slotSizeX) * span
    breaks = numeric(length(temp) + 2)
    breaks[2:(length(temp) + 1)] = temp
    breaks[1] = temp[1] - diff(c(temp[1], temp[2])) * 1.001
    breaks[length(breaks)] = rev(temp)[1] + diff(c(temp[1], 
                                                   temp[2])) * 1.001
    breaks = temp2
  }
  slotSizeY = strheight(pch.size, units = "user", cex = cex)
  if (DB) 
    print(paste("slotSizeY:", slotSizeY))
  span = diff(ylim)
  temp1 = ppoints(2 * ceiling(span/slotSizeY))
  temp2 = numeric(length(temp1) + 2)
  temp2[2:(length(temp1) + 1)] = temp1
  temp2[1] = temp2[1] - 1.01 * diff(c(temp1[1], temp1[2]))
  temp2[length(temp2)] = rev(temp1)[1] + 1.01 * diff(c(temp1[1], 
                                                       temp1[2]))
  yVec = temp2 * span + min(ylim)
  if (yVec[1] < 0) 
    yVec = yVec + abs(yVec[1])
  else yVec = yVec - yVec[1]
  if (DB) 
    print(paste("temp2:", temp2))
  if (DB) 
    print(paste("breaks:", breaks))
  histObj = hist(x, breaks = breaks, right = FALSE, plot = FALSE)
  hMids = histObj$mids
  hCounts = histObj$counts
  hMids = histObj$mids
  mat = matrix(NA, nrow = length(x), ncol = length(hMids))
  colMat = mat
  groupmat = mat
  numVec = 1:nrow(mat)
  cutOff = 1
  groupList = vector(mode = "list", length = length(unique(group)))
  for (k in unique(group)) {
    histObj = hist(x[group == k], breaks = breaks, plot = FALSE)
    hMids = histObj$mids
    hCounts = histObj$counts
    hMids = histObj$mids
    for (i in seq(along = hMids)) {
      value = pch[k]
      colValue = col[k]
      from = 0
      from = numVec[is.na(mat[, i])][1]
      to = from
      if (hCounts[i] == 0) 
        value = NA
      if (hCounts[i] >= 1) 
        to = to + hCounts[i] - 1
      if (to > cutOff) 
        cutOff = to
      if (DB) {
        print(paste("from:", from))
        print(paste("to:", to))
        print(paste("i:", i))
        print(paste("value:", value))
      }
      mat[from:to, i] = value
      colMat[from:to, i] = colValue
    }
    groupList[[k]] = groupmat
  }
  if (grouped && !stacked) {
    groupIndex = unique(group)
    par(mfrow = c(length(groupIndex), 1))
    for (i in groupIndex) dotPlot(x[group == i], xlim = xlim, 
                                  breaks = breaks, cex = cex, xlab = xlab, ylab = ylab, 
                                  col = col, pch = pch, ...)
  }
  else {
    mat = mat[1:cutOff, ]
    if (!is.matrix(mat)) 
      mat = matrix(mat, nrow = 1)
    if (DB) 
      print(mat)
    #     plot(1, 1, xlim = xlim, ylim = ylim, type = "n", cex = cex, 
    #          xlab = xlab, ylab = ylab, ...)
    for (i in 1:nrow(mat)) {
      x = hMids[!is.na(mat[i, ])]
      y = rep(i * 0.3, times = length(x))
      y = rep(yVec[i], times = length(x))
      col = colMat[i, !is.na(mat[i, ])]
      pch = mat[i, !is.na(mat[i, ])]
      points(x, y, col = col, pch = pch, cex = cex,
             xlim = xlim, ylim = ylim, 
             xlab = xlab, ylab = ylab)
    }
    grid();
    title(main)
  }
  if (DB) 
    print(hMids)
  invisible(mat)
}

plotAP <- function (act,prd,title="title",flip=F,rounder=identity,usejitter=F,m=NULL) {    
  print(title);
  if(!is.null(m)) { 
    #print(goodness.of.fit(m = m)) ##goodness of fit test
    print(resettest(m)) #ovtest, Ramsey's RESET, test for underfitting
    print(bptest(m)); # Breusch-Pagan test against heteroskedasticity.
    if(resettest(m)$p.value<0.05){
      ##not well spec'ed
      #       m.ov=lm(act~prd+I(prd^2)+I(prd^3));
      #       m.ov=stepAIC(m.ov,trace=0);
      #       say("RESET A.R2=",adj.rsq(actual = act,pred = prd,p=length(coef(m))+3),"> Mod A.R2=",(summary(m))$adj.r.squared)
      #       if(adj.rsq(actual = act,pred = prd,p=length(coef(m))+3) > (summary(m))$adj.r.squared){
      #         print(summary(m.ov))
      #       }
    }    
  } 
  plot(jitter(prd),jitter((act-prd)/rmse(act,prd)),main="jittered std residuals")
  hist(act-prd,main="hist of residuals")
  prd=winsor1(prd,lbl = 'prd');
  prd=rounder(prd)  
  if(!is.null(m) && class(m)!="rq"){
    ram("Model Tests","leveraged=",sprintf("%0.3f",max(cooks.distance(model = m))),
        "HoHomosc=",sprintf("%0.3f",bptest(m)$p.value),
        "HoGoodSpec=",sprintf("%0.3f",resettest(m)$p.value),title); 
  }
  say(length(prd),length(act))
  ram("Residuals","resHoNorm=",sprintf("%0.3f",shapiro.test(sample(act-prd,min(4999,length(prd))))$p.value),
      "resSkew=",sprintf("%0.2f",skewness(act-prd)),title);
  ram("Fit",
      "aR2=",round(100*adj.rsq(act,prd,length(coef(m))),1),"%",
      "R2=",round(100*rsq(act,prd),1),"%",
      "cor=",round(100*cor(act,prd),1),"%",
      "rmse=",round(rmse(act,prd,k=if(is.null(m)){1}else{length(coef(m));}),1),
      "RSD%=",round(100*rmse(act,prd,k=if(is.null(m)){1}else{length(coef(m));})/mean(act),1),
      "range%=",round(100*diff(range(prd))/diff(range(act))),           
      title);  
  #            "MMPS=",round(100*minmax.percent.same(act,prd),1),"%",
  #            "SMAPE1=",round(100*SMAPE1(act,prd),1),"%",
  #            "MAE=",round(MAE(act,prd),1),
  
  title=paste0(title," cor=",round(100*cor(act,prd)),"%")
  multihist(list(act=act,prd=prd),title=paste("hist of ",title))
  d=data.frame(act=act,prd=prd);
  d=d[order(d$prd),]
  act=d$act;
  prd=d$prd;
  
  say("rmse",rmse(act,prd))
  width=trunc(length(prd)/100)
  if(is.even(width)) width=width+1;
  #https://en.wikipedia.org/wiki/Symmetric_mean_absolute_percentage_error
  #   residualWA <- as.numeric(filter(abs(prd-act)/((abs(act)+abs(prd))/2), rep(1/width,width), sides=2))
  #   plot((prd),(residualWA),  col="red",main="windowed residuals SMAPE")  
  ##GRAPH1
  if(flip){
    d=d[order(d$act),]
    act=d$act;
    prd=d$prd;    
    plot((act),(prd),main=title,cex=0.3)  
    abline(lm(predicted ~ actual,data.frame(actual=act,predicted=prd)),col="blue")  
    prdMA <- as.numeric(filter(prd, rep(1/width,width), sides=2))
    lines(act,prdMA,  col="red")  
    grid()   
  }else{
    plot((prd),(act),main=title,cex=0.3)  
    abline(lm(actual ~ predicted,data.frame(actual=act,predicted=prd)),col="blue")  
    actMA <- as.numeric(filter(act, rep(1/width,width), sides=2))
    lines(prd,actMA,  col="red")  
    grid()       
  }
  if(!is.null(m)){ cat(getModelEquation(m)); }
}


getModelEquation=function(m,link='identity',bounded=T,sql=F,fraction=.005){
  if(!sql) cat('double calc_',all.vars(m$terms)[1],'(){//generated by getModelEquation\n',sep='')
  v=names(coefficients(m));
  if(!sql)
    for(n in v[grep('.*_.*',v)]){
      cat(n,'=',sub('.+_','',n),'(',sub('_.+','',n),");\n");
    }
  fun=''
  funEnd=''
  if(link=='logit'){
    fun='1.0/(1.0 + EXP( -1.0 * ('
    funEnd=')))'
    bounded=F
  }
  if(bounded)
    bnd=paste("pmax(",quantile(predict(m),fraction),
              ",pmin(",quantile(predict(m),1-fraction),",")
  else bnd="(("
  ass=paste0(all.vars(m$terms)[1]," = ")
  assEnd=''
  if(sql){
    ass=''
    assEnd=paste0(' as ',all.vars(m$terms)[1],",")
  }
  if(v[1]=='(Intercept)') {
    answer=paste0(ass,fun,
                  paste(bnd,
                        coefficients(m)[1], " + ", 
                        paste(sprintf("%s * %s", 
                                      coefficients(m)[-1],  
                                      names(coefficients(m)[-1])), 
                              collapse=" + ")
                        ,"))",funEnd,assEnd
                  )
    )
  }else{
    answer=paste0(ass,fun,
                  paste(bnd,
                        paste(sprintf("%s * %s", 
                                      coefficients(m),  
                                      names(coefficients(m))), 
                              collapse=" + ")
                        ,"))",funEnd,assEnd
                  )
    )
  }
  catln(answer)
  catln(';\nreturn ',all.vars(m$terms)[1],";\n}")
  answer
}


ChebyshevRule=function(k) { 
  #minimum proportion of data values that fall within k standard deviations of the mean
  1-(1/k^2); 
}

#mean absolute error (MAE)
MAE=function(act,pred) mean(abs(pred-act))
SMAPE1=function(a,p) mean(abs(a-p)/((abs(a)+abs(p))))
pbigger=function(x,y) ifelse(abs(x)>abs(y),x,y)
psmaller=function(x,y) ifelse(abs(x)<abs(y),x,y)
#minmax.percent.error=function(a,p) mean( pmin(a,p)/ifelse(pmax(a,p)==0,1,pmax(a,p)))
minmax.percent.same=function(a,p) mean( psmaller(a,p)/ifelse(pbigger(a,p)==0,1,pbigger(a,p)))

#https://en.wikipedia.org/wiki/Symmetric_mean_absolute_percentage_error
#this is a made up function that can go neg
adjusted.smape1=function(a,p,deg=0) 1-(1/(length(a)-deg)*((abs(a-p)/((abs(a)+abs(p))))));

#require(gtools)





#####DANGER
###
##compute the rank of the target and determines the best box cox function for that target
findBestBoxCoxPolyXDanger=function(df,yvar,xvars=names(df),
                                   ignore=c(),upper=4,step=1,rename=T,trace=F,
                                   specials=c('loglevel','loglog'),IMPROV=1.001,rows=getTestTrainRows(df)){
  metric=function(act,pred,deg=0) (1/(length(act)-deg)*sum(abs(pred-act)));    
  isbetter=function(x,y) {
    #say("better",x,y)
    if(x<y){T;}else{F;}
  }
  lmrob=function(f,df){
    yvar=all.vars(as.formula(f))[1]
    m1=lm(f,df);  
    iqr=IQR(m1$residuals);
    cutter=quantile(abs(m1$residuals),probs = 0.75);
    good=which( abs(m1$residuals)<=cutter);
    if(length(good)!=nrow(df)){
      #say("rows elim",length(good),"!=",nrow(df));
      dfG=df[good,];
      m2=lm(f,dfG);##only train on good ones
      m2=stepAIC(m2,trace=0);
      res=predict(m2,df); ##predict on all
      if(isbetter(metric(df[,yvar],res),metric(df[,yvar],m1$residuals))){
        return(m2); 
      }
    }
    return(m1); ##best one
  }
  
  
  bestRsqs=c();  
  #improv is the minimum amount of improvement in rsquared to bother with transform
  target=df[,yvar];
  for(xvar in xvars){
    if(xvar == yvar) next;
    if(xvar %in% ignore) next;        
    x=df[,xvar];    
    if(length(unique(x))<3) next; #only 2 values or less!
    new.xvar=xvar;
    #let's anchor close to 1.0 http://pareonline.net/getvn.asp?v=8&n=6
    offset=(1-min(x));    
    centering=signif(-mean(x),4); 
    bestRsq=abs(metric(target,x)); #baseline unaltered
    if(is.na(bestRsq)) bestRsq=0;
    baseRsq=bestRsq;
    better=FALSE;
    bestx=x;
    ##for proportional data    
    if(min(x)==0 && max(x)==100){
      x=x/100; ##try proportional
    }
    if(min(x)>=0 && max(x)<=1){
      say("proportional",xvar);
      epsilonA=min(abs(0-x[x>0]))/2;
      epsilonB=min(1-x[x<1])/2.0;
      x=ifelse(x==0,epsilonA,ifelse(x==1,epsilonB,x))
      x=logit(x);
      if(all(!is.na(x))) {        
        r=abs(metric(x,target,1));
        if(!is.na(r)){
          if(isbetter(r,(bestRsq*IMPROV))){
            bestRsq=r;
            better=T
            bestx=x;
            new.xvar=paste0(xvar,'_logit','a',makeNegUnderscore(epsilonA),'b',makeNegUnderscore(epsilonB));
            if(trace) say("BETTER",xvar,yvar,"rsq=",signif(bestRsq,2),new.xvar);
          }
        }
      }
    }
    ##for boxcox
    for(tryoff in unique(c(0,offset,(0-min(x))))){
      for(i in c(1/2,0,2,1/3,-1)){ #(seq(-1,2,0.1))){
        if(i==1 && tryoff==0){
          next;
        }else{
          x=df[,xvar];
          x=x+tryoff;   
          #was log or x=(x^i - 1.0)/i;
          ##x=forecast::BoxCox(x,i);        
          bias=ifelse(x<=0,1,0);
          if(i==0){
            x=ifelse(x<=0,0,log(x)); ##this may produce false warning
          }else{            
            x=ifelse(x<=0,0,x^i);
          }          
        }
        if(any(is.na(x))) {
          say("NaNs",i,tryoff,xvar);
          next;
        }
        tdf=data.frame(target=target,x=x,bias=bias);
        if(max(bias)==1){
          tlm=lmrob(target~x+bias+1,tdf[rows$train,]);          
        }else{
          tlm=lmrob(target~x+1,tdf[rows$train,]);
        }         
        if(length(tlm$coefficients) > tlm$rank){          
          print(summary(tlm))
          say(xvar,'i=',i,'tro=',tryoff,length(tlm$coefficients)," > ",tlm$rank)
          hist(x)
          print(length(x));
          print(length(bias));
          print(length(unique(x)));
          print(length(unique(bias)));
          warning("rank deficient pow ",xvar,i,' ',tryoff);
          next;
        }
        x=predict(tlm,tdf);
        if(any(is.na(x))) next;        
        r=abs(metric(x[rows$test],target[rows$test],length(coef(tlm))-1));
        if(is.na(r)) next;
        if(isbetter(r,(bestRsq*IMPROV))){
          bestRsq=r;
          better=T
          bestx=x;
          new.xvar=paste0(xvar,'_pow','_p',makeNegUnderscore(tryoff),'_',makeNegUnderscore(i));
          if(trace) say("BETTER",xvar,yvar,"pow=",i,"rsq=",signif(bestRsq,2),new.xvar);
        }else{
          if(trace) say("NO BETTER",xvar,yvar,"pow=",i,"rsq=",signif(r,2),'pow');
        }
      }  
    }
    ##for log level    
    for(special in c('loglevel','loglog')){
      x=df[,xvar];
      x=x+offset;
      yoffset=(1-min(target));   
      y=log(target+yoffset);
      if(!any(is.na(y)) && !any(is.na(x))){
        if(special=='loglevel'){ #exponential regression 
          m.lm=lmrob(y~x,data.frame(y=y,x=x));
          a=exp(m.lm$coefficients[1])
          b=exp(m.lm$coefficients[2])                      
          x=(a*b^x)-yoffset;                  
        }else if(special=='loglog'){ #power regression http://www.real-statistics.com/regression/power-regression/
          m.lm=lmrob(y~I(log(x)),data.frame(y=y,x=x));
          a=exp(m.lm$coefficients[1])
          b=(m.lm$coefficients[2])                      
          x=(a*x^b)-yoffset;      
        }else{
          stop("not special",special); 
        }          
        #         px=exp(predict(m.lm))-yoffset;
        #         say('rmse between ',special,' and equation',rmse(x,px))
        r=abs(metric(x,y,2)); #penalty
        if(!is.na(r) && isbetter(r,(bestRsq*IMPROV))){
          bestRsq=r;
          better=T
          bestx=x
          new.xvar=paste0(xvar,'_',special,'_px',makeNegUnderscore(offset),
                          '_py',makeNegUnderscore(yoffset),
                          '_a',makeNegUnderscore(a),
                          '_b',makeNegUnderscore(b));
          if(trace) say("BETTER",xvar,yvar,"rsq=",signif(bestRsq,2),new.xvar);
        }
      }
    }
    ##for poly
    tdf=data.frame(x1=1:nrow(df));
    tdf[,yvar]=target;
    formulaStr=paste(yvar,"~");
    for(i in (seq(1,upper,step))){ 
      x=df[,xvar];
      x=x+centering;
      newXterm=paste0(xvar,'x',i);
      tdf[,newXterm]=x^i;
      formulaStr=paste(formulaStr,newXterm,'+');      
      trainer=tdf[rows$train,];
      tlm=lmrob(as.formula(paste(formulaStr,'1')),trainer); 
      #tlm=stepAIC(tlm,trace=0);
      if( length(tlm$coefficients)> tlm$rank){
        print(summary(tlm))
        stop("rank deficient",xvar,i);
      }
      x=predict(tlm,tdf);
      if(any(is.na(x))) next;
      r=abs(metric(x[rows$test],target[rows$test],i));
      if(is.na(r)) next;
      if(isbetter(r,(bestRsq*IMPROV))){        
        if(trace) print(summary(tlm))
        bestRsq=r;
        better=T
        bestx=x;
        new.xvar=paste0(xvar,'_poly','_p',makeNegUnderscore(centering),'_',makeNegUnderscore(i));
        if(trace) say("BETTER",xvar,yvar,"poly=",i,"rsq=",signif(bestRsq,10));
      }else{
        if(i>1) break; #give up
      }
    }        
    bestRsqs=c(bestRsqs,bestRsq);
    say("BEST",better,yvar,round(bestRsq/baseRsq,2)-1,signif(baseRsq,2),signif(bestRsq,2),new.xvar);
    if(better){
      if(rename){
        df[,new.xvar]=bestx;
        df[,xvar]=NULL;        
      }else{
        df[,xvar]=bestx;
      }
    }
  }  
  say('meanRsq',mean(bestRsqs),'sumRsq',sum(bestRsqs),'bestRsq',max(bestRsqs),'worstRsq',min(bestRsqs))
  df;
}


##http://stackoverflow.com/questions/13644529/how-to-create-a-stacked-line-plot
stackplot = function(data, ylim=NA, main=NA, colors=NA, xlab=NA, ylab=NA,...) {
  # stacked line plot
  if (is.na(ylim)) {
    ylim=c(0, max(rowSums(data, na.rm=T)))
  }
  if (is.na(colors)) {
    colors = c("green","red","lightgray","blue","orange","purple", "yellow")
  }
  xval = as.numeric(row.names(data))
  summary = rep(0, nrow(data))
  recent = summary
  
  # Create empty plot
  plot(c(-100), c(-100), xlim=c(min(xval, na.rm=T), max(xval, na.rm=T)), ylim=ylim, main=main, xlab=xlab, ylab=ylab,...)
  
  # One polygon per column
  cols = names(data)
  chosen=c()
  for (c in 1:length(cols)) {
    current = data[[cols[[c]]]]
    summary = summary + current
    polygon(
      x=c(xval, rev(xval)),
      y=c(summary, rev(recent)),
      col=colors[[c]])
    chosen[c]=colors[[c]];
    recent = summary
  }
  legend('topleft', legend = cols, pch=c(1),col=chosen,bty = "y",horiz=F) 
}

cook.influentials=function(m){
  #this finds those observations that out too influential
  cd=cooks.distance(model = m)
  tossing=which(cd>4/(length(cd)-length(coef(m))))
  catln("cooking boiling off",length(tossing),"of", length(cd),"is",round(100*length(tossing)/length(cd)),"%")
  return(tossing);
}

cook.model=function(m,tossing=-1*cook.influentials(m)){
  #this cooks the model by removing elements that have leverage
  #the idea is to test this with a test set.  
  require(formula.tools)
  if(length(tossing)==0){
    message("all good none to boil away");
    return(m);
  }
  f=formula(m)
  subw=m$weights
  subdf=m$model[,all.vars(f)]
  print(f)  
  subdf=subdf[tossing,];  ##note the -1 above!!
  if(is.null(subw)){
    m2=lm(formula(as.character(f)),subdf); 
  }else{
    subw=subw[tossing];
    m2=lm(formula(as.character(f)),subdf,weights = subw); 
  }
  m2=stepAIC(m2,trace=F)  
  cat('m adj.r.squared=',summary(m)$adj.r.squared,
      ' m.sigma=',summary(m)$sigma,
      '\nm2 adj.r.squared=',summary(m2)$adj.r.squared,      
      ' m2.sigma=',summary(m2)$sigma,
      "\n")
  m2;
}

regressmore=function(m,act){
  ##inspired by RESET test
  ##not well spec'ed??    
  subw=m$weights  
  if(!is.null(subw)) message("using weights");
  prd=predict(m);  
  scaled.prd=prd-mean(prd);
  say("mean of prd is",mean(prd))
  say("length of prd",length(prd))
  say("length of scaled.prd",length(scaled.prd))
  say("length of act",length(act))
  say("length of subw",length(subw))
  if(length(prd)==length(act)){
    m.ov=lm(act~prd+I(scaled.prd^2)+I(scaled.prd^3),
            data = data.frame(act=act,prd=prd,scaled.prd=scaled.prd),weights = subw);
    m.ov=stepAIC(m.ov,trace=0);
    return(m.ov);
    #return(m);
  }else{
    print("not same length!!");
    return( m);
  }
}

createUnitTests=function(df,df2,m){
  set.seed(nrow(df))
  #df is the raw data
  #df2 is used for predictions
  v=all.vars(formula(m));
  for(r in sample(nrow(df),5)){
    cat("@Test\n","public void ",paste0("testRecord",r,"()")," {\n");
    cat("//test #",r,"\n");
    for(nn in v[2:length(v)]){
      for(n in unique(unlist(strsplit(nn,':')))){
        cat(n,'=',df[r,n],';\n');      
      }
    }
    cat(v[1],'=calc();\n');
    cat('target=',predict(m,df2[r,]),";\n");
    cat('assertEquals("',as.character(formula(m)),'",',v[1],',target,0.1);\n');
    cat("}\n");
  }
}

createUnitTests2=function(df,df2,m,funcName="testRecord",N=5){ 
  ##use this one for colon interaction fields
  #df is the raw data
  #df2 is used for predictions, it is the model matrix data frame
  q=function(x) paste0('"',x,'"')
  v=all.vars(formula(m));
  for(r in sample(nrow(df),N)){
    needed=list();
    output=c()
    cat("@Test\n","public void ",paste0(funcName,r,"()")," {\n");
    catln("object=createTestObject();")
    cat("//test #",r,"\n");
    for(nn in v[-1]){
      for(n in unique(unlist(strsplit(nn,':')))){
        if(n %in% names(df)){
          if(is.numeric( df[r,n])){
            output=c(output,'object.',paste0(n,'=',df[r,n],';\n'));      
          }else{
            output=c(output,'object.',paste0(n,'=',q(df[r,n]),';\n'));      
          }  
        }else{
          gotit=F
          slen=nchar(n)-1
          while(slen>1){
            nn=substr(n,1,slen)
            if(nn %in% names(df)) {
              needed[[paste0('',nn,'=')]]=q(df[r,nn])
              output=c(output,'object.',paste0(n,'=sameAs(',nn,",",q(substr(n,slen+1,nchar(n))),');\n'));      
              gotit=T
              break;
            }
            slen=slen-1
          }
          if(!gotit){
            if(is.numeric( df2[r,n])){
              output=c(output,'object.',paste0(n,'=',df2[r,n],'; //this is a computed field, please put in computation here\n'));      
            }else{
              output=c(output,'object.',paste0(n,"='",df2[r,n],"'; //this is a computed field, please put in computation here\n"));      
            }  
          }
        }
      }
    }
    for(x in names(needed)){
      cat(x)
      cat(needed[[x]])
      cat('\n')
    }
    for(x in output){
      cat(x)
    }
    cat('ans=calc',funcName,'(object);\n',sep='');
    cat('target=',predict(m,df2[r,]),";\n");
    cat('assertEquals("',as.character(formula(m)),'",','target,ans,0.1);\n');
    cat("}\n");
  }
}


makeTimesModelFormula=function(df,yvar,xvars=names(df),shun.dummies=F){
  dummies=c();
  others=c();
  for(n in xvars){
    if(n==yvar) next;
    if(min(df[,n])==0 && max(df[,n])==1){
      dummies=c(dummies,n); 
    }else{
      others=c(others,n);
    }
  }
  if(length(dummies)==0){
    return(paste(yvar,'~ (',paste(others,collapse = '+'),')^2'))
  }else if(length(others)==0){
    return(paste(yvar,'~ (',paste(dummies,collapse = '+'),')^2'))
  }else{
    if(shun.dummies) {
      return(paste(yvar,'~ (',paste(c(others),collapse = '+'),')*(',paste(dummies,collapse = '+'),')'));      
    }else{
      return(paste(yvar,'~ (',paste(c(others,dummies),collapse = '+'),')*(',paste(dummies,collapse = '+'),')'));      
    }
  }
}

cor.numeric=function(df,y=NULL){
  nums <- sapply(df, is.numeric)
  cor(df[ , nums],y)
}

ks.score=function(m,df,yvar=all.vars(formula(m))[1],show=T){
  ##https://cran.r-project.org/doc/contrib/Sharma-CreditScoring.pdf
  ##ks.score for logistic regression, higher the better
  prd<-predict(m,type='response',df)
  act=df[[yvar]]
  ks.scoreAP(act,prd,yvar,show);
}

#returns ks score
ks.scoreAP=function(act,prd,yvar='',show=T){  
  require(ROCR)
  message(length(act))
  message(length(prd))
  message(rmse(act,prd))
  pred<-prediction(prd,act)
  perf <- performance(pred,"tpr","fpr")
  #this code builds on ROCR library by taking the max delt
  #between cumulative bad and good rates being plotted by
  #ROCR see https://cran.r-project.org/doc/contrib/Sharma-CreditScoring.pdf
  ans=max(attr(perf,'y.values')[[1]]-attr(perf,'x.values')[[1]])
  if(show){
    plot(perf,main=paste0(yvar,' KS=',round(ans*100,1),'%'))
    lines(x = c(0,1),y=c(0,1))
  }
  ram("ks.score",ans,yvar)
  ans;
}

ks.scoreB=function(m,df,yvar=all.vars(formula(m))[1]){
  ##https://cran.r-project.org/doc/contrib/Sharma-CreditScoring.pdf
  ##ks.score for logistic regression, higher the better
  score<-predict(m,type='response',df)
  act=df[[yvar]];
  data=data.frame(prd=score,act=act);
  goods=sum(act>0.5);
  bads=sum(act<=0.5);
  step=0.1
  r=0;
  breaks=quantile(score,probs=seq(0,1,0.1))
  d=data.frame(row=1:(length(breaks)-1))
  for(w in 2:length(breaks)){
    h=breaks[w-1]
    i=breaks[w]+(w==length(breaks))
    r=r+1
    d[r,'score']=i;
    d[r,'score']=mean(data[data$prd>=h & data$prd,'prd']);
    if(r==1){
      d[r,'goods']=nrow(data[data$prd>=h & data$prd<i & data$act>0.5,])/goods;
      d[r,'bads']=nrow(data[data$prd>=h & data$prd<i & data$act<=0.5,])/bads;
    }else{
      d[r,'goods']=d[r-1,'goods']+nrow(data[data$prd>=h & data$prd<i & data$act>0.5,])/goods;
      d[r,'bads']=d[r-1,'bads']+nrow(data[data$prd>=h & data$prd<i & data$act<=0.5,])/bads;
    }
    d[r,'ks']=abs(d[r,'goods']-d[r,'bads'])
  }
  d$row=NULL
  ezplot1(df = d,xvar='score',type='b',title=paste0(yvar,' KS Analysis KS=',round(100*max(d$ks),1),"%"))
  max(d$ks)
}

collections.performance=function(m,df,yvar=all.vars(formula(m))[1],pretty=T){
  ##https://cran.r-project.org/doc/contrib/Sharma-CreditScoring.pdf
  ##ks.score for logistic regression, higher the better
  score<-predict(m,type='response',df)
  act=df[[yvar]];
  data=data.frame(prd=score,act=act);
  goods=sum(act);
  step=0.1
  d=data.frame(row=1:(1/step))
  r=0;
  collectedPerMost='collected/most'
  cols=c('records%','sum%')
  breaks=quantile(score,probs=seq(0,1,0.1))
  for(w in 2:length(breaks)){
    h=breaks[w-1]
    i=breaks[w]+(w==length(breaks))
    r=r+1
    d[r,'score']=mean(data[data$prd>=h & data$prd,'prd']);
    if(r==1){
      for(n in cols){  d[r,n]=0; }
    }else{
      for(n in cols){  
        d[r,n]=d[r-1,n]
      }
    }
    inc(d[r,'records%'],sum(data$prd>=h & data$prd<i)/nrow(data));
    inc(d[r,'sum%'],sum(data[data$prd>=h & data$prd<i,'act'])/goods);
    d[r,'total%']=sum(data[data$prd>=h & data$prd<i,'act'])/goods;
    d[r,collectedPerMost]=mean(data[data$prd>=h & data$prd<i,'act']);
  }
  dollars=d[,collectedPerMost]
  d[,collectedPerMost]=d[,collectedPerMost]/max(d[,collectedPerMost])
  d$row=NULL
  if(pretty){
    d=100*d
    d$score=d$score*10
  }
  ezplot1(df = d,xvar='score',type='b',title=paste(yvar,'analysis'),
          xlab = paste0('Portfolio value $',round(goods)))
  d$dollarsPerRecord=dollars
  if(pretty)  round(d);
}


bounded=function(x,lower,upper=lower[2]) {
  pmax(lower[1],pmin(upper,x))
}


`%inrange%`<-function(x,rng) x>=rng[1] & x<=rng[2] ##similar to sql
`%between%`<-function(x,rng) x>=rng[1] & x<=rng[2] ##similar to sql

bunch.decile=function(x){
  signif(quantile(x,seq(0.05,0.95,length.out = 10),na.rm = T)[1+floor(rank(x)/(1+length(x))*10)],2)
} 

bunch.decile=function(x){
  signif(quantile(x,seq(0.05,0.95,length.out = 10),na.rm = T)[1+floor(rank(x)/(1+length(x))*10)],2)
} 

bunch.decile.index=function(x,ntiles=10){
  1+floor(rank(x)/(1+length(x))*ntiles)
}
bunch.decile.names=function(x,ntiles=10){
  signif(quantile(x,seq(1/ntiles/2,1-1/ntiles/2,length.out = ntiles),na.rm = T),2)
}
bunch.by.width=function(act) {
  bucketWidth=10^round(log((max(act)-min(act))/10,10))
  round(act/(bucketWidth))*bucketWidth
}

bunch.by.cut=function(x,breaks=10){
  brk=as.numeric(cut(x,breaks = breaks))
  a=aggregate(x,list(brk=brk),mean)
  a$x=signif(a$x,3)
  ##print(a)
  a$x[brk]
}

ezheatmap=function(act,prd,title=paste(xlab,'vs',ylab), 
                   bucketWidth=10^round(log((max(act)-min(act))/10,10)),
                   #bunch=function(x) round(x/(bucketWidth))*bucketWidth,
                   bunch=bunch.decile,
                   scaled=F,
                   xlab=rev(as.character(substitute(act)))[1],
                   ylab=rev(as.character(substitute(prd)))[1],percents=F,trace=F
){
  mytable=table(pred=bunch(prd),actuals=bunch(act))
  if( trace) print(title);
  if( trace) print(mytable)
  if( trace)  print(round(100*mytable/sum(mytable)))
  if(percents){
    mytable=round(100*mytable/sum(mytable))
  }
  ma=as.matrix(mytable);
  #rownames(ma)=signif(as.numeric(rownames(ma)),2)
  #colnames(ma)=signif(as.numeric(colnames(ma)),2)
  if(scaled) {
    for(col in 1:ncol(ma)){ ma[,col]=ma[,col]/sum(ma[,col]);}
    gplots::heatmap.2(ma,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none',
                      main=title,ylab=ylab,xlab=xlab,cellnote=round(100*ma),notecol='black')  
  }else{
    gplots::heatmap.2(ma,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none',
                      main=title,ylab=ylab,xlab=xlab,cellnote=ma,notecol='black')  
  }
  require(ineq)
  ram("Gini",'Gini',Gini(act),Gini(prd),title);
  ram("RMSE",'RMSE',rmse(act,prd),title);
  ram("Matched",'Matched',round(100*sum(bunch(act)==bunch(prd))/length(prd),1),'%',title);
}


ezheatmap.same.breaks=function(act,prd,title=paste(xlab,'vs',ylab), 
                               numbuckets=10,
                               scaled=F,
                               xlab=rev(as.character(substitute(act)))[1],
                               ylab=rev(as.character(substitute(prd)))[1],percents=F,trace=F
){
  x=cut(c(act,prd),numbuckets)
  bucks=levels(x)
  
  act2=as.numeric(x)[1:length(act)]
  prd2=as.numeric(x)[-1*(1:length(act))]
  mytable=table(pred=prd2,actuals=act2)
  if( trace) print(title);
  if( trace) print(mytable)
  if( trace)  print(round(100*mytable/sum(mytable)))
  if(percents){
    mytable=round(100*mytable/sum(mytable))
  }
  ma=as.matrix(mytable);
  rownames(ma)=bucks[as.numeric(rownames(ma))]
  colnames(ma)=bucks[as.numeric(colnames(ma))]
  if(scaled) {
    for(col in 1:ncol(ma)){ ma[,col]=ma[,col]/sum(ma[,col]);}
    gplots::heatmap.2(ma,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none',
                      main=title,ylab=ylab,xlab=xlab,cellnote=round(100*ma),notecol='black')  
  }else{
    gplots::heatmap.2(ma,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none',
                      main=title,ylab=ylab,xlab=xlab,cellnote=ma,notecol='black')  
  }
  require(ineq)
  ram("Gini",'Gini',Gini(act),Gini(prd),title);
  ram("RMSE",'RMSE',rmse(act,prd),title);
  #ram("Matched",'Matched',round(100*sum(bunch(act)==bunch(prd))/length(prd),1),'%',title);
}




ezheatmapz=function(x,y,z,use.heatmap=T,main=rev(as.character(substitute(z)))[1],FUN=mean,
                    bucketx=bunch.decile.index(x),
                    buckety=bunch.decile.index(y),
                    bucketz=bunch.decile.index(z),
                    ntile=max(length(unique(bucketx)),length(unique(buckety))),autotile=0,col=NULL,...
){
  if(autotile>0){
    ntile=autotile
    bucketx=bunch.decile.index(x,ntiles = autotile)
    buckety=bunch.decile.index(y,ntiles = autotile)
    bucketz=bunch.decile.index(z,ntiles = autotile)
  }
  xlab=paste(rev(as.character(substitute(x)))[1],'decile')
  ylab=paste(rev(as.character(substitute(y)))[1],'decile')
  zlab=rev(as.character(substitute(z)))[1]
  aggx=aggregate(x,list(bucketx=bucketx),FUN=median)
  aggy=aggregate(y,list(buckety=buckety),FUN=median)
  agg=aggregate(z,list(bucketx=bucketx,buckety=buckety),FUN=FUN)
  #   print(aggx)
  #   print(aggy)
  #   print(summary(agg))
  if(use.heatmap){
    ma=matrix(data = NA,nrow = ntile,ncol=ntile)
    for(i in 1:nrow(agg))    { #slow
      ma[agg$buckety[i],agg$bucketx[i]]=agg$x[i]
    }
    ma=signif(ma,2)
    colnames(ma)=rep('',ntile)
    rownames(ma)=rep('',ntile)
    #     print(aggx)
    #     print(colnames(ma))
    for(i in 1:nrow(aggx))    { #slow
      colnames(ma)[aggx$bucketx[i]]=signif(aggx$x[i],2)
    }
    for(i in 1:nrow(aggy))    { #slow
      rownames(ma)[aggy$buckety[i]]=signif(aggy$x[i],2)
    }
    
    library(RColorBrewer)
    numbreaks=ntile*ntile/2
    breaks=unique(sort(quantile(as.vector(ma),probs = seq(1/numbreaks/2,1-1/numbreaks/2,length.out = numbreaks),na.rm = T)))
    colorz <- colorRampPalette(c("red", "yellow"))(n = length(breaks)-1)
    #print(breaks)
    #plot(breaks)
    gplots::heatmap.2(ma,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none',
                      main=main,ylab=ylab,xlab=xlab,cellnote=ma,notecol='black',na.color='gray',
                      breaks=breaks,col=colorz,key=F,density.info='density',
                      symkey=F)   
  }else{
    symbols(agg$bucketx,agg$buckety,squares=sqrt( agg$x ),inches=1,fg="white", bg=heat.colors(11)[1+bucketz],xlab=xlab,ylab=ylab)
    text(agg$bucketx,agg$buckety, round(agg$x,2), cex=1)
    title(zlab)
  }
}

multi.density.plot=function(data,main=paste(names(data),collapse = ' vs '),standardized=F,...){
  ##combines multiple density plots together when given a list
  df=data.frame();
  for(n in names(data)){
    if(class(data[[n]])=='factor') next;
    if(standardized) data[[n]]=(data[[n]]-mean(data[[n]],na.rm = T))/sd(data[[n]],na.rm = T)
    idf=data.frame(x=data[[n]],label=rep(n,length(data[[n]])))
    df=rbind(df,idf)
  }
  require(lattice)
  densityplot(~x,data=df,groups = label,plot.points = F, ref = T, auto.key = list(space = "right"),main=main,...)
}


piece.formula <-function(df,var.name,
                         K=5,
                         knots=unique(quantile(df[[var.name]],probs = seq(0,1,length.out=K+2))[-c(1, K + 2)]),
                         yvar=NULL
) { 
  ### this makes knot hinges for piece wise regression
  ### This works for only one variable.
  ##model <- lm(formula(paste("y ~", piece.formula(df,"x", knots))))
  ##m3=stepAIC(lm(piece.formula(df = d3,yvar = 'HRC',var.name = 'LN',K = 10),d3))
  knots=knots[knots!=0]
  formula.sign <- rep(" - ", length(knots))
  formula.sign[knots < 0] <- " + "
  foo=paste(var.name, "+",
            paste("I(pmax(", var.name, formula.sign, abs(knots), ", 0))",
                  collapse = " + ", sep=""))
  if(!is.null(yvar)){
    paste(yvar,'~',foo)
  }else{
    foo
  }
}


hinge.formula <- function(df,xvars=names(df),yvar,K=floor((nrow(df2)-20)/(15*(length(xvars)))-1),
                          degree=1,natural=F) {
  ### this makes knot hinges for linear spline regression
  ### This works for more than 1 xvar
  ##m=lm(hinge.formula(madedf,yvar='bills',xvars = qw('cs rcl'),K=4),df)
  if(natural) degree=3;
  maxK=floor((nrow(df2)-20)/(15*(length(xvars)))-1)
  if(K>maxK) warning("K over MAX K!")
  catln('hinge.formula K=',K,', max is ',maxK,' based on n=',nrow(df),' p=',length(xvars),sep='')
  fs=paste(yvar,'~')
  for(var.name in xvars) {
    if(var.name != yvar){
      if(K<3 || !natural){
        probs=seq(0,1,length.out=K+2)[-c(1, K + 2)]
      }else{ #natural splines
        #Analysis of Health Surveys,By Edward L. Korn, Barry I. Graubard p.98
        #Durrleman and Simon (1989) for natural splines
        probs=seq(0.05,0.95,length.out=K) 
        probs=seq(0,1,length.out=K)
      }
      knots=unique(quantile(df[[var.name]],probs = probs))
      knots=knots[knots!=0]
      print(probs)
      print(knots)
      if(natural){
        if(degree!=3) stop("invalid degree")
        parts=c(var.name)
        k=length(knots)
        if(k>=3){
          for(i in 1:(k-2)) {
            parts=c(parts,'+ I(',
                    #  pmax(0,var.name-knots[i])^3  
                    'pmax(0,',var.name,'-',knots[i],')^3',
                    #  - ((knots[k]-knots[i])  /(knots[k]-knots[k-1]))*pmax(0,var.name - knots[k-1])^3
                    ' - (',(knots[k]-knots[i])  /(knots[k]-knots[k-1]),')*pmax(0,',var.name,' - ',knots[k-1],')^3',
                    #  + ((knots[k-1]-knots[i])/(knots[k]-knots[k-1]))*pmax(0,var.name - knots[k])^3      
                    ' + (',(knots[k-1]-knots[i])/(knots[k]-knots[k-1]),')*pmax(0,',var.name,' - ',knots[k],')^3)')
          }
        }
        fs=paste(fs,'+',paste(parts,collapse = ' '),collapse = ' ')
      }else{
        formula.sign <- rep(" - ", length(knots))
        formula.sign[knots < 0] <- " + "
        if(degree==1){
          fs=paste(fs,'+',var.name,"+",
                   paste("I(pmax(", var.name, formula.sign, abs(knots), ", 0))",
                         collapse = " + ", sep=""))  
        }else{
          fs=paste(fs,'+',
                   paste0('I(',rep(var.name,degree),'^',1:degree,')',collapse = ' + '), 
                   "+",
                   paste("I(pmax(", var.name, formula.sign, abs(knots), paste0(", 0)^",degree,")"),
                         collapse = " + ", sep=""))
        }
      }
    }
  }
  fs
}



ezcloud=function(x,data,...){
  ##remember to pass in group
  cloud(x, data = data,          
        drape = TRUE,scale=list(arrows=F),
        colorkey = TRUE,col.regions =  terrain.colors(100)[1:95],...) 
}

ez3d=function(x,y,z){
  require(rgl)
  plot3d(x,y,z,col = z) 
}

ezagg=function(FUN=function(x) c(median=median(x),mean=mean(x),count=length(x),sd=sd(x)),
               ...){
  return(as.data.frame(as.list(aggregate(FUN=FUN,...))))
}

install.a.bunch=function(){
  install.packages(qw('formula.tools
                      gains
                      lmtest
                      ggplot2
                      reshape2
                      ggthemes
                      VIF
                      cvTools
                      glmnet
                      ROCR
                      moments
                      cvTools
                      qualityTools
                      gtools'))
  
}

ezstatebins.count=function(df,statecolumn){
  #this counts up the occurrences of the state column
  require(statebins)
  require(plyr)
  x=count(df,statecolumn)
  x[[statecolumn]]=as.character(x[[ statecolumn ]])
  statebins_continuous(x,statecolumn,'freq',legend_position='none')
}

ezstatebins=function(df,state.column,value.column,suffix='',label.column=value.column,
                     use.abbrev=T,
                     main='State Map',value.label=value.column,default='',
                     col=colorRampPalette(c("yellow","red"))(10)){
  require(statebins)
  if(use.abbrev)  states=data.frame(abbrev=df[,state.column],value=df[,value.column],label=df[,label.column])
  else states=data.frame(state=df[,state.column],value=df[,value.column],label=df[,label.column])
  r=as.data.frame(merge(statebins:::state_coords,states,all.x=T,all.y=T))
  r[r$abbrev=='AK',c('row','col')]=c(1,1)
  r[r$abbrev=='PA',c('row','col')]=c(3,9)
  r[r$abbrev=='OH',c('row','col')]=c(4,9)
  r[r$abbrev=='IL',c('row','col')]=c(4,7)
  r[r$abbrev=='WI',c('row','col')]=c(3,7)
  r[r$abbrev=='IN',c('row','col')]=c(4,8)
  require(reshape)
  nums=''
  if(!(label.column %in% F)){
    nums=paste0(as.character(signif(r$label,2)),suffix)
    nums[is.na(nums)]=default
    nums[nums==paste0('NA',suffix)]=default
    nums=paste0("\n",nums,sep="")
  }
  r$av=paste(r$abbrev,nums,sep="")
  
  ##for some odd reason, this returns only numbers: print(cast(row~col,data=r,value='av'))
  ##so just created a tmp data.frame as workaround
  tmpd=data.frame(row=r$row,col=r$col,t=r$av)
  labels=reshape::cast(row~col,data=tmpd,value='t')
  
  data=data.matrix(reshape::cast(row~col,data=r,value='value'))
  rownames(data) <- colnames(data) <- NULL
  data=data[,-1]
  labels=labels[,-1]
  
  gplots::heatmap.2(data,dendrogram='none', Rowv=FALSE, Colv=FALSE,trace='none',
                    cellnote=labels,notecol='black',density.info='none',margins = c(1, 1),
                    key.title='states',labRow=NA,labCol = NA,col=col, 
                    main=main,key.xlab=value.label)
}

#d=data.frame(abbrev=c('MN','FL'),value=c(12,23))
#ezstatebins(d,'abbrev','value')


ezbarplot.count=function(df,statecolumn,main=paste(statecolumn," percentage")){
  #this counts up the occurrences of the state column
  #require(statebins)
  require(plyr)
  x=count(df,statecolumn)
  x[[statecolumn]]=as.character(x[[ statecolumn ]])
  print(head(x))
  y=x$freq/sum(x$freq)*100
  xx=barplot(y,names.arg = x[[statecolumn]],las=2,col=rainbow(length(x$freq)),panel.first={
    title(main)
  })
  text(x = xx, y = y/2, label = signif(y,2), pos = 3, cex = 0.8, col = "black")
  #barplot(x$freq/sum(x$freq)*100,names.arg = x[[statecolumn]],las=2,col=rainbow(length(x$freq)),add=T)
  box()
}


ez.cheat.selection=function(m,threshold=0.05){
  ##Not really correct, cheats by looking at p-values
  v=row.names(coef(summary(m)))[coef(summary(m))[,4]<=threshold]
  v=setdiff(v,"(Intercept)")
  c(all.vars(m$terms)[1],v)
}

###
.ls.objects <- function (pos = 1, pattern, order.by = "Size", decreasing=TRUE, head = TRUE, n = 10) {
  # based on postings by Petr Pikal and David Hinds to the r-help list in 2004
  # modified by: Dirk Eddelbuettel (http://stackoverflow.com/questions/1358003/tricks-to-manage-the-available-memory-in-an-r-session) 
  # I then gave it a few tweaks (show size as megabytes and use defaults that I like)
  # a data frame of the objects and their associated storage needs.
  napply <- function(names, fn) sapply(names, function(x)
    fn(get(x, pos = pos)))
  names <- ls(pos = pos, pattern = pattern)
  obj.class <- napply(names, function(x) as.character(class(x))[1])
  obj.mode <- napply(names, mode)
  obj.type <- ifelse(is.na(obj.class), obj.mode, obj.class)
  obj.size <- napply(names, object.size) / 10^6 # megabytes
  obj.dim <- t(napply(names, function(x)
    as.numeric(dim(x))[1:2]))
  vec <- is.na(obj.dim)[, 1] & (obj.type != "function")
  obj.dim[vec, 1] <- napply(names, length)[vec]
  out <- data.frame(obj.type, obj.size, obj.dim)
  names(out) <- c("Type", "Size", "Rows", "Columns")
  out <- out[order(out[[order.by]], decreasing=decreasing), ]
  if (head)
    out <- head(out, n)
  out
}


remove.BOM <- function(df) { names(df)=c(substring(names(df)[1], 4),names(df)[-1]); df; }
remove.BOM.simple <- function(df) {substring(names(df)[1], 4) }

cor2=function(df,yvar){
  cdf=as.data.frame(cor(df,df[[yvar]]))
  result=list('(Intercept)'=0)
  df$Temp=df[[yvar]]
  cdf[order(abs(cdf$V1)),,drop=F]
}


##what does this do??!?!
foo=function(df,yvar){
  cdf=as.data.frame(cor(df,df[[yvar]]))
  result=list('(Intercept)'=0)
  df$Temp=df[[yvar]]
  for(n in row.names(cdf[order(-abs(cdf$V1)),,drop=F])){
    if(n==yvar) next
    message(n)
    m=lm(as.formula(paste('Temp ~',n)),df)
    inc(result[['(Intercept)']],coef(m)[1])
    inc(result[[n]],coef(m)[n])
    df$Temp=m$residuals
  }
  df$Temp=NULL
  m=lm(paste(yvar,'~.'),df)
  print(summary(m))
  for(n in names(coef(m))){
    message(sprintf("%-15s %f",n,result[[n]]))
  }
}


fetchLines=function(inputFile,match,fixed=T,n=100,maxlines=100000){ #inputFile='simple.csv'; match='APPLE';
  message('reading:',inputFile)
  n=min(n,maxlines)
  con  <- base::file(inputFile, open = "r",encoding = "UTF-8-BOM")
  data=c(readLines(con, n = 1, warn = FALSE))
  while (length(oneLine <- readLines(con, n = n, warn = FALSE)) > 0) {
    grab=grep(match,oneLine,value=T,fixed=fixed)
    if(length(grab)>0){
      data=c(data,grab)
      if(length(data)>maxlines){
        warning("bailing out too many");
        return(data);
      }
      cat('.')
    }
  } 
  close(con)
  gc()
  cat("\n")
  data;
}
#x=fetchLines("disease-cv-all.csv",'\\bP58\\b',fixed=F,maxlines = 10000)


stripGlmLR = function(cm) {
  ##reduces memory of a model
  #http://www.win-vector.com/blog/2014/05/trimming-the-fat-from-glm-models-in-r/
  cm$y = c()
  cm$model = c()
  
  cm$residuals = c()
  cm$fitted.values = c()
  cm$effects = c()
  cm$qr$qr = c()  
  cm$linear.predictors = c()
  cm$weights = c()
  cm$prior.weights = c()
  cm$data = c()
  
  
  cm$family$variance = c()
  cm$family$dev.resids = c()
  cm$family$aic = c()
  cm$family$validmu = c()
  cm$family$simulate = c()
  attr(cm$terms,".Environment") = c()
  attr(cm$formula,".Environment") = c()
  
  cm
}


prf <- function(predAct){
  ## predAct is two col dataframe of pred,act
  ##
  # Function: evaluation metrics
  ## True positives (TP) - Correctly idd as success
  ## True negatives (TN) - Correctly idd as failure
  ## False positives (FP) - success incorrectly idd as failure
  ## False negatives (FN) - failure incorrectly idd as success
  ## Precision - P = TP/(TP+FP) how many idd actually success/failure
  ## Recall - R = TP/(TP+FN) how many of the successes correctly idd
  ## F-score - F = (2 * P * R)/(P + R) harm mean of precision and recall
  preds = predAct[,1]
  trues = predAct[,2]
  xTab <- table(preds, trues)
  clss <- as.character(sort(unique(preds)))
  r <- matrix(NA, ncol = 7, nrow = 1, 
              dimnames = list(c(),c('Acc',
                                    paste("P",clss[1],sep='_'), #PREDICTIVE VALUE
                                    paste("R",clss[1],sep='_'), #TPR
                                    paste("F",clss[1],sep='_'), 
                                    paste("P",clss[2],sep='_'), #PREDICTIVE VALUE
                                    paste("R",clss[2],sep='_'), #TRUE RATE
                                    paste("F",clss[2],sep='_'))))
  r[1,1] <- sum(xTab[1,1],xTab[2,2])/sum(xTab) # Accuracy
  r[1,2] <- xTab[1,1]/sum(xTab[,1]) # Miss Precision
  r[1,3] <- xTab[1,1]/sum(xTab[1,]) # Miss Recall
  r[1,4] <- (2*r[1,2]*r[1,3])/sum(r[1,2],r[1,3]) # Miss F
  r[1,5] <- xTab[2,2]/sum(xTab[,2]) # Hit Precision
  r[1,6] <- xTab[2,2]/sum(xTab[2,]) # Hit Recall
  r[1,7] <- (2*r[1,5]*r[1,6])/sum(r[1,5],r[1,6]) # Hit F
  r
}

cor.most=function(df,var){
  m=cor(df,y=df[[var]])
  row.names(m)
  mm=data.frame(k=row.names(m),v=m)
  mm[order(abs(mm$v)),]
}


read.clip.lastFileName=NULL
read.clip=function(fn="clipboard",header=T,na.strings = c("NULL","NA"),read.last=F){
  if(read.last) fn=read.clip.lastFileName;
  if(fn=='clipboard'){
    df=read.table(fn,header = header,na.strings = na.strings,stringsAsFactors = F,row.names = NULL,sep='\t') 
    fn=paste0(paste(c('clipboard',names(df)),collapse = '_'),'.csv')
    message("writing file ",fn)
    write.csv(df,fn,row.names = F)
    read.clip.lastFileName<<-fn
  }else{
    ## df=read.csv(fn,header = T,na.strings = c("NULL","NA"),stringsAsFactors = F,row.names = NULL) 
    df=read.csv(fn,header = header,na.strings = na.strings,stringsAsFactors = F,row.names = NULL) 
  }
  df
}


rename.columns=function(df,changelist){
  #renames columns of a dataframe via list(oldname=newname)
  for(i in 1:length(names(df))){
    if(length(changelist[[names(df)[i]]])>0){
      message(names(df)[i]," renamed columns to ",changelist[[names(df)[i]]])
      names(df)[i]= changelist[[names(df)[i]]]
    }
  }
  df
}

isnull=function(a,b){
  ifelse(is.null(a) | is.na(a),b,a)
}




train.multinomial=function(df,yvar,trainRows=1:nrow(df),discard.columns=c(),target=yvar,speedy=F){
  ######################################################################
  #multinomial logit via equality
  # yvar must be discrete AND MUST?? BE NUMERIC (PERHAPS factors will work??)
  ######################################################################
  if(!(is.factor(df[[yvar]]) || is.all.whole.numbers(df[[yvar]]))) stop("NOT ALL WHOLE NUMBERS")
  print(unique(sort(df[[yvar]])))
  models=list()
  for(i in unique(sort(df[[yvar]]))){
    cat("analyzing",i," of ",yvar,"\n")
    df[[paste0(target,i)]]=ifelse(df[[yvar]]==i,1,0)
    if(speedy){
      cat("speedy mode\n")
      v=ez.cheat.selection(m = lm(as.formula(paste(paste0(target,i),'~.')),
                                  data=discard(df,c(yvar,discard.columns))[trainRows,]))
      if(length(v)>1){
        print(v)
        m<-(glm(ezformula(v),family=binomial(link='logit'),data=df[trainRows,]))
        v=ez.cheat.selection(m)
        print(v)
        m<-(glm(ezformula(v),family=binomial(link='logit'),data=df[trainRows,]))
        m=stepAIC(m)
        models[[paste0(i)]]<-stripGlmLR(m)
        gc()
        print(summary(m))
      }  
    }else{
      v=ezlasso(discard(df,c(yvar,discard.columns))[trainRows,],  paste0(target,i))
      if(length(v)>1){
        print(v)
        models[[paste0(i)]]<-m<-stepAIC(glm(ezformula(v),family=binomial(link='logit'),data=df[trainRows,]),trace=F)
        print(summary(m))
      }
    }
    df[[paste0(target,i)]]=NULL
  }
  tf=data.frame(bogus=1:nrow(df))
  for(i in names(models)){
    tf[[i]]=predict(models[[i]],df,type="response")
    cat(getModelEquation(models[[i]],link="logit",sql=T),"\n")
    tf$bogus=NULL 
  }
  local({
    arr=sort(names(models),decreasing = T)
    arr=names(models)
    cat("CASE ")
    for(i in 1:(length(arr)-1)){
      #   CASE WHEN fs1>fs2 AND fs1>fs3 AND fs1>fs4 AND fs1>fs5 THEN 1
      #   WHEN fs2>fs3 AND fs2>fs4 AND fs2>fs5 THEN 2
      #   WHEN fs3>fs4 AND fs3>fs5 THEN 3
      #   WHEN fs4>fs5 THEN 4
      #   ELSE 5 END) AS phFamilySizeEst,
      cat(" when ")
      if(i+1<length(arr))
        for(j in (i+1):(length(arr)-1)){
          #message(i,' ',j)
          cat(target,arr[i],' > ',target,isnull(arr[j],-1),' AND ',sep = '')
        }
      #message(i,' x ',j)
      cat(target,arr[i],' > ',target,isnull(arr[length(arr)],-1),' THEN ',arr[i],"\n",sep='')
    }   
    cat(' ELSE',arr[length(arr)],'END\n')
  }   )     
  
  best=(sort(names(models))[apply(tf[,sort(names(models))],1,which.max)])
  hist(as.numeric(best))
  return(list(models=models,best=best))
}  

McFaddenR2=function(m,llhNull=NULL){# McFadden's R squared
  if(is.null(llhNull)){
    objectNull <- update(m, ~1)
    llhNull <- logLik(objectNull)
  }
  c(mr2=1-logLik(m)/llhNull,
    adj.mr2=1-(logLik(m)-(length(coef(m))-1))/llhNull)
  #http://thestatsgeek.com/2014/02/08/r-squared-in-logistic-regression/
  #http://www.ats.ucla.edu/stat/mult_pkg/faq/general/Psuedo_RSquareds.htm
}

quick.pnorm=function(x,a=mean(x),s=sd(x)) { 1.0/(1.0+exp(-1.69897*(x-a)/s)) }
ez.pnorm=function(x,a=mean(x),s=sd(x)) { pnorm(x,mean = a,sd = s); }

##https://en.wikipedia.org/wiki/Softmax_function#Softmax_normalization
softmax.norm=function(x,a=mean(x),s=sd(x),C=-1){ 1.0/(1.0+exp(C*(x-a)/s))}
softmax.denorm=function(x,a,s,C=-1){ (-log(1/x-1))*s+a }
softmax=function(x) { exp(x) /sum(exp(x)) }

softmax.norm.tanh=function(x,a=mean(x),s=sd(x),C=-1){ (1.0-exp(C*(x-a)/s))/(1.0+exp(C*(x-a)/s))}
softmax.denorm.tanh=function(x,a,s,C=-1){ (log((1+x)/(1-x)))*s+a }


geo.mean=function(x) { exp(mean(log(x))) }
ihs.mean=function(x) { sinh(mean(asinh(x))) }
pop.var <- function(x) var(x) * (length(x)-1) / length(x)
pop.sd <- function(x) sqrt(pop.var(x))

pareto.MLE <- function(X) { #http://stats.stackexchange.com/questions/27426/how-do-i-fit-a-set-of-data-to-a-pareto-distribution-in-r
  n <- length(X)
  m <- min(X)
  a <- n/sum(log(X)-log(m))
  return( c(m=m,a=a) ) ##equiv pnorm function is (a*m^a)/x^(a+1)
}

moving.average <- function(x,n=5){filter(x,rep(1/n,n), sides=2)}

catln=function(...) { cat(...,"\n")}

print.environment=function(h) {
  for( n in sort(ls(h))) { 
    if(is.numeric(h[[n]]) || is.character(h[[n]]) ) 
      cat(n,' ',as.character(h[[n]]),"\n")
    else cat(n,' ',class(h[[n]]),"\n")
  }
}

nrow=function(x){
  if(class(x)=='list') {
    length(x[[names(x)[1]]])
  }else{
    base::nrow(x)
  }
}

plotdensity=function(x) {
  #require(e1071)
  xx=density(x)
  main=sprintf("%s skew:%.2f",deparse(match.call()),e1071::skewness(x))
  plot(xx,main=main)
}


coef.beta.lm=function(m){
  require(lm.beta)
  lm.beta(m)
}
coef.beta.lm.as.df=function(m){
  given(as.data.frame((coef.beta.lm(m)$standardized.coefficients)),{ .$names=row.names(.); .[order(abs(.[,1]),decreasing = T),]})
}


coef.beta.logistic=function(m){
  #http://stats.stackexchange.com/questions/197699/what-is-the-formula-of-beta-coefficient-in-logistic-regression/243439#243439
  md=  as.data.frame(model.matrix(m$formula, m$data))
  sd2=function(x) sd(x,na.rm = T)
  coef(m)[-1]*sapply(md,sd2)[names(coef(m))[-1]]
}
coef.beta.logistic.as.df=function(m){
  given(as.data.frame((coef.beta.logistic(m))),{ .$names=row.names(.); .[order(abs(.[,1]),decreasing = T),]})
}

find.bad.contrasts=function(df,good=F,xvars=names(df)){
  bad=c()
  isgood=c()
  for(n in xvars){
    if(length(unique(df[,n]))<=1 || (is.factor(df[[n]]) && length(levels(df[,n]))<=1)){
      catln(n,'is bad');  
      bad=c(bad,n)
    }else{
      isgood=c(isgood,n)
    }
  }
  if(good) {
    isgood
  }else{
    bad
  }
}

coalesce <- function(...) { #http://stackoverflow.com/a/19257945/4634775
  ans <- ..1
  for (elt in list(...)[-1]) {
    i <- which(is.na(ans))
    ans[i] <- elt[i]
  }
  ans
}


slm=function(...){
  m=lm(...)
  require(MASS)
  m=stepAIC(m,trace = F)
  print(summary(m))
  m
}

#http://stackoverflow.com/questions/13093912/how-to-check-if-a-sequence-of-numbers-is-monotonically-increasing-or-decreasing
is.monotonic.increasing=function(x) all(x == cummax(x))
is.monotonic.decreasing=function(x) all(x == cummin(x))




image.nan.better <- function(mat,  zlim=range(mat,na.rm=T), col=heat.colors(12), na.color='gray', outside.below.color='black', outside.above.color='white',...){
  ##this draws an image but colors NaN differently.
  z=mat
  zstep <- (zlim[2] - zlim[1]) / length(col); # step in the color palette
  newz.below.outside <- zlim[1] - 2 * zstep # new z for values below zlim
  newz.above.outside <- zlim[2] + zstep # new z for values above zlim
  newz.na <- zlim[2] + 2 * zstep # new z for NA
  
  z[which(z<zlim[1])] <- newz.below.outside # we affect newz.below.outside
  z[which(z>zlim[2])] <- newz.above.outside # we affect newz.above.outside
  z[which(is.na(z>zlim[2]))] <- newz.na # same for newz.na
  
  zlim[1] <- zlim[1] - 2 * zstep # extend lower limit to include below value
  zlim[2] <- zlim[2] + 2 * zstep # extend top limit to include the two new values above and na
  catln(zlim)
  col <- c(outside.below.color, col[1], col, outside.above.color, na.color) #correct by including col[1] at bottom of range
  
  image(z=z,  zlim=zlim, col=col, ...) # we finally call image(...)
}


###########
#' Create SQL statement from rpart rules
#'
#' Rpart rules are changed to sql CASE statement.
#'
#' @param df data frame used for rpart model
#' @param model rpart model
#' @export
#' @examples
#' parse_tree(df=kyphosis,model=rpart(data=kyphosis,formula=Kyphosis~.))
#' parse_tree(df=mtcars,model=rpart(data=mtcars,formula=am~.))
#' parse_tree(df=iris,model=rpart(data=iris,formula=Species~.))
#' x <- german_data
#' x$gbbin <- NULL
#' model <- rpart(data=x,formula=gb~.)
#' parse_tree(x,model)

parse_tree <- function (df=NULL, model=NULL) { #https://gist.github.com/tomasgreif/6038822
  log <- capture.output({
    rpart.rules <- path.rpart(model,rownames(model$frame)[model$frame$var=="<leaf>"])
  })  
  
  args <- c("<=",">=","<",">","=")
  rules_out <- "case "
  i <- 1
  
  for (rule in rpart.rules) {  
    rule_out <- character(0)
    for (component in rule) {
      sep <- lapply(args, function(x) length(unlist(strsplit(component,x)))) > 1
      elements <- unlist(strsplit(component,(args[sep])[1]))
      if(!(elements[1]=="root")) {
        if (is.numeric(df[,elements[[1]]])) {
          rule_out <- c(rule_out,paste(elements[1],(args[sep])[1],elements[2]))
        } else {
          rule_out <- c(rule_out,paste0(elements[1]," in (",paste0("'",unlist(strsplit(elements[2],",")),"'",collapse=","),")"))
        }
      }
    }
    rules_out <- c(rules_out, paste0("when ", paste(rule_out,collapse=" AND ")," then 'node_" ,names(rpart.rules)[i],"'"))
    if(i==length(rpart.rules)) rules_out <- c(rules_out," end ")
    i <- i +1
  }
  sql_out <- paste(rules_out, collapse=" ")
  sql_out  
}


#' darken
#'
#' @param color 
#' @param factor 
#'
#' @return
#' @export
#'
#' @examples
darken <- function(color, factor=1.4){ #darkens colors
  col <- col2rgb(color)
  col <- col/factor
  col <- rgb(t(col), maxColorValue=255)
  col
}


normalize=function(x) {
  (x-min(x,na.rm = T))/(max(x,na.rm = T)-min(x,na.rm = T))
}

shush=function(...) invisible(capture.output(suppressMessages(suppressPackageStartupMessages(suppressWarnings(...)))))



plot_counties=function(df,yvar,
                       discrete=is.factor(df[[yvar]]),main=yvar,ylab=yvar,
                       low=NA,high=NA,
                       legend.position="right",na.value="lightgray",
                       print=T){
  g=plot_usmap(regions = 'counties',data=df,
               value=yvar,lines=NA) + ggtitle(main)
  if(!is.na(low)){
    if(discrete){
      g=g+scale_fill_manual(values =
                              c(colorRampPalette(c(low, high))( length(unique(df[[yvar]])) )),
                            name= ylab,na.value=na.value)
    }else{
      g=g+scale_fill_continuous(low=low, high=high, 
                                guide="colorbar",na.value=na.value,name = ylab)
    }
  }else{
    if(discrete){
      g=g+scale_fill_manual(values =
                              c(rainbow( length(unique(df[[yvar]])) )),
                            name= ylab,na.value=na.value)
    }else{
      g=g+scale_fill_continuous(name = ylab,na.value=na.value)
    }
  }
  if(legend.position=='bottom'){
    g=g+theme(legend.position="top",legend.direction="horizontal",
              plot.title = element_text(hjust = 0.5))   
  }else{
    g=g+theme(legend.position=legend.position,plot.title = element_text(hjust = 0.5)) 
  }
  if(print){
    print(g)
  }else{
    g
  }
}  


#https://stackoverflow.com/a/7660073/4634775
invwhich <- function(indices, totlength) is.element(seq_len(totlength), indices)

used.rpart.vars=function(mtree){
  names(sort(mtree$variable.importance[as.character(unique(mtree$frame$var[!(mtree$frame$var == "<leaf>")]))],decreasing = T))
}

print_rpart=function (x, minlength = 0L, spaces = 2L, cp, digits = getOption("digits"),
                      nlab='n:',ylab='y:',  ...) {
  if (!inherits(x, "rpart")) 
    stop("Not a legitimate \"rpart\" object")
  if (!missing(cp)) 
    x <- prune.rpart(x, cp = cp)
  frame <- x$frame
  ylevel <- attr(x, "ylevels")
  node <- as.numeric(row.names(frame))
  depth <- rpart:::tree.depth(node)
  indent <- paste(rep(" ", spaces * 32L), collapse = "")
  indent <- if (length(node) > 1L) {
    indent <- substring(indent, 1L, spaces * seq(depth))
    paste0(c("", indent[depth]), format(node), ")")
  }
  else paste0(format(node), ")")
  tfun <- (x$functions)$print
  yval <- if (!is.null(tfun)) {
    if (is.null(frame$yval2)) 
      tfun(frame$yval, ylevel, digits)
    else tfun(frame$yval2, ylevel, digits)
  }
  else format(signif(frame$yval, digits))
  term <- rep(" ", length(depth))
  term[frame$var == "<leaf>"] <- "*"
  z <- labels(x, digits = digits, minlength = minlength, ...)
  n <- frame$n
  ##                              *       
  z <- paste(indent, z, paste0(nlab,n), paste0(ylab,yval), term)
  omit <- x$na.action
  if (length(omit)) 
    cat("n=", n[1L], " (", naprint(omit), ")\n\n", sep = "")
  else cat("n=", n[1L], "\n\n")
  if (x$method == "class") 
    cat("node), split, n, loss, yval, (yprob)\n")
  else cat("node), split, n, yval\n")
  cat("      * denotes terminal node\n\n")
  cat(z, sep = "\n")
  invisible(x)
}


##https://stackoverflow.com/questions/13593196/standard-deviation-of-combined-data
## N: vector of sizes
## M: vector of means
## S: vector of standard deviations - try to use pop.sd
grand.mean <- function(M, N) {weighted.mean(M, N)}
grand.sd   <- function(S, M, N) {sqrt(weighted.mean(S^2 + M^2, N) - weighted.mean(M, N)^2)}




##eof











